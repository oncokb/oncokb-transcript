/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AllReferenceTranscriptSuggestionVM
 */
export interface AllReferenceTranscriptSuggestionVM {
  /**
   *
   * @type {TranscriptSuggestionVM}
   * @memberof AllReferenceTranscriptSuggestionVM
   */
  grch37?: TranscriptSuggestionVM;
  /**
   *
   * @type {TranscriptSuggestionVM}
   * @memberof AllReferenceTranscriptSuggestionVM
   */
  grch38?: TranscriptSuggestionVM;
}
/**
 *
 * @export
 * @interface Alteration
 */
export interface Alteration {
  /**
   *
   * @type {number}
   * @memberof Alteration
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  alteration: string;
  /**
   *
   * @type {number}
   * @memberof Alteration
   */
  proteinStart?: number;
  /**
   *
   * @type {number}
   * @memberof Alteration
   */
  proteinEnd?: number;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  refResidues?: string;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  variantResidues?: string;
  /**
   *
   * @type {Set<AlterationReferenceGenome>}
   * @memberof Alteration
   */
  referenceGenomes?: Set<AlterationReferenceGenome>;
  /**
   *
   * @type {Set<Gene>}
   * @memberof Alteration
   */
  genes?: Set<Gene>;
}
/**
 *
 * @export
 * @interface AlterationCriteria
 */
export interface AlterationCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof AlterationCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof AlterationCriteria
   */
  name?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof AlterationCriteria
   */
  alteration?: StringFilter;
  /**
   *
   * @type {IntegerFilter}
   * @memberof AlterationCriteria
   */
  proteinStart?: IntegerFilter;
  /**
   *
   * @type {IntegerFilter}
   * @memberof AlterationCriteria
   */
  proteinEnd?: IntegerFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof AlterationCriteria
   */
  refResidues?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof AlterationCriteria
   */
  variantResidues?: StringFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof AlterationCriteria
   */
  deviceUsageIndicationId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof AlterationCriteria
   */
  referenceGenomesId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof AlterationCriteria
   */
  geneId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof AlterationCriteria
   */
  consequenceId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof AlterationCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface AlterationReferenceGenome
 */
export interface AlterationReferenceGenome {
  /**
   *
   * @type {number}
   * @memberof AlterationReferenceGenome
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof AlterationReferenceGenome
   */
  referenceGenome?: AlterationReferenceGenomeReferenceGenomeEnum;
  /**
   *
   * @type {Alteration}
   * @memberof AlterationReferenceGenome
   */
  alteration?: Alteration;
}

export const AlterationReferenceGenomeReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type AlterationReferenceGenomeReferenceGenomeEnum =
  typeof AlterationReferenceGenomeReferenceGenomeEnum[keyof typeof AlterationReferenceGenomeReferenceGenomeEnum];

/**
 *
 * @export
 * @interface Article
 */
export interface Article {
  /**
   *
   * @type {number}
   * @memberof Article
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pmid?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  journal?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pubDate?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  volume?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  issue?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pages?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  authors?: string;
}
/**
 *
 * @export
 * @interface ArticleCriteria
 */
export interface ArticleCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof ArticleCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  pmid?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  journal?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  pubDate?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  volume?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  issue?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  pages?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ArticleCriteria
   */
  authors?: StringFilter;
  /**
   *
   * @type {boolean}
   * @memberof ArticleCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface AuthInfoVM
 */
export interface AuthInfoVM {
  /**
   *
   * @type {string}
   * @memberof AuthInfoVM
   */
  issuer?: string;
  /**
   *
   * @type {string}
   * @memberof AuthInfoVM
   */
  clientId?: string;
}
/**
 *
 * @export
 * @interface BooleanFilter
 */
export interface BooleanFilter {
  /**
   *
   * @type {boolean}
   * @memberof BooleanFilter
   */
  equals?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof BooleanFilter
   */
  notEquals?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof BooleanFilter
   */
  specified?: boolean;
  /**
   *
   * @type {Array<boolean>}
   * @memberof BooleanFilter
   */
  in?: Array<boolean>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof BooleanFilter
   */
  notIn?: Array<boolean>;
}
/**
 *
 * @export
 * @interface CancerType
 */
export interface CancerType {
  /**
   *
   * @type {number}
   * @memberof CancerType
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  color?: string;
  /**
   *
   * @type {number}
   * @memberof CancerType
   */
  level: number;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  mainType: string;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  subtype?: string;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  tissue?: string;
  /**
   *
   * @type {string}
   * @memberof CancerType
   */
  tumorForm: CancerTypeTumorFormEnum;
}

export const CancerTypeTumorFormEnum = {
  Solid: 'SOLID',
  Liquid: 'LIQUID',
  Mixed: 'MIXED',
} as const;

export type CancerTypeTumorFormEnum = typeof CancerTypeTumorFormEnum[keyof typeof CancerTypeTumorFormEnum];

/**
 *
 * @export
 * @interface CategoricalAlteration
 */
export interface CategoricalAlteration {
  /**
   *
   * @type {number}
   * @memberof CategoricalAlteration
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CategoricalAlteration
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CategoricalAlteration
   */
  type: CategoricalAlterationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CategoricalAlteration
   */
  alterationType: CategoricalAlterationAlterationTypeEnum;
}

export const CategoricalAlterationTypeEnum = {
  OncogenicMutations: 'ONCOGENIC_MUTATIONS',
  GainOfFunctionMutations: 'GAIN_OF_FUNCTION_MUTATIONS',
  LossOfFunctionMutations: 'LOSS_OF_FUNCTION_MUTATIONS',
  SwitchOfFunctionMutations: 'SWITCH_OF_FUNCTION_MUTATIONS',
  Vus: 'VUS',
  TruncatingMutations: 'TRUNCATING_MUTATIONS',
  Fusions: 'FUSIONS',
  Amplification: 'AMPLIFICATION',
  Deletion: 'DELETION',
  Promoter: 'PROMOTER',
  Wildtype: 'WILDTYPE',
} as const;

export type CategoricalAlterationTypeEnum = typeof CategoricalAlterationTypeEnum[keyof typeof CategoricalAlterationTypeEnum];
export const CategoricalAlterationAlterationTypeEnum = {
  Mutation: 'MUTATION',
  CopyNumberAlteration: 'COPY_NUMBER_ALTERATION',
  StructuralVariant: 'STRUCTURAL_VARIANT',
  Unknown: 'UNKNOWN',
  Na: 'NA',
} as const;

export type CategoricalAlterationAlterationTypeEnum =
  typeof CategoricalAlterationAlterationTypeEnum[keyof typeof CategoricalAlterationAlterationTypeEnum];

/**
 *
 * @export
 * @interface ClinicalTrialsGovCondition
 */
export interface ClinicalTrialsGovCondition {
  /**
   *
   * @type {number}
   * @memberof ClinicalTrialsGovCondition
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ClinicalTrialsGovCondition
   */
  name: string;
  /**
   *
   * @type {Set<CancerType>}
   * @memberof ClinicalTrialsGovCondition
   */
  cancerTypes?: Set<CancerType>;
}
/**
 *
 * @export
 * @interface ClinicalTrialsGovConditionCriteria
 */
export interface ClinicalTrialsGovConditionCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof ClinicalTrialsGovConditionCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof ClinicalTrialsGovConditionCriteria
   */
  name?: StringFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof ClinicalTrialsGovConditionCriteria
   */
  cancerTypeId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof ClinicalTrialsGovConditionCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface CompanionDiagnosticDevice
 */
export interface CompanionDiagnosticDevice {
  /**
   *
   * @type {number}
   * @memberof CompanionDiagnosticDevice
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CompanionDiagnosticDevice
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CompanionDiagnosticDevice
   */
  manufacturer: string;
  /**
   *
   * @type {Set<FdaSubmission>}
   * @memberof CompanionDiagnosticDevice
   */
  fdaSubmissions?: Set<FdaSubmission>;
  /**
   *
   * @type {Set<SpecimenType>}
   * @memberof CompanionDiagnosticDevice
   */
  specimenTypes?: Set<SpecimenType>;
}
/**
 *
 * @export
 * @interface CompanionDiagnosticDeviceCriteria
 */
export interface CompanionDiagnosticDeviceCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  name?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  manufacturer?: StringFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  fdaSubmissionId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  specimenTypeId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof CompanionDiagnosticDeviceCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface Consequence
 */
export interface Consequence {
  /**
   *
   * @type {number}
   * @memberof Consequence
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Consequence
   */
  type: ConsequenceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Consequence
   */
  term: string;
  /**
   *
   * @type {string}
   * @memberof Consequence
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof Consequence
   */
  isGenerallyTruncating: boolean;
  /**
   *
   * @type {string}
   * @memberof Consequence
   */
  description?: string;
  /**
   *
   * @type {Set<Alteration>}
   * @memberof Consequence
   */
  alterations?: Set<Alteration>;
}

export const ConsequenceTypeEnum = {
  Mutation: 'MUTATION',
  CopyNumberAlteration: 'COPY_NUMBER_ALTERATION',
  StructuralVariant: 'STRUCTURAL_VARIANT',
  Unknown: 'UNKNOWN',
  Na: 'NA',
} as const;

export type ConsequenceTypeEnum = typeof ConsequenceTypeEnum[keyof typeof ConsequenceTypeEnum];

/**
 *
 * @export
 * @interface DeviceUsageIndication
 */
export interface DeviceUsageIndication {
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndication
   */
  id?: number;
  /**
   *
   * @type {FdaSubmission}
   * @memberof DeviceUsageIndication
   */
  fdaSubmission?: FdaSubmission;
  /**
   *
   * @type {Alteration}
   * @memberof DeviceUsageIndication
   */
  alteration?: Alteration;
  /**
   *
   * @type {CancerType}
   * @memberof DeviceUsageIndication
   */
  cancerType?: CancerType;
  /**
   *
   * @type {Drug}
   * @memberof DeviceUsageIndication
   */
  drug?: Drug;
}
/**
 *
 * @export
 * @interface DeviceUsageIndicationDTO
 */
export interface DeviceUsageIndicationDTO {
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndicationDTO
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndicationDTO
   */
  fdaSubmission?: number;
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndicationDTO
   */
  alteration?: number;
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndicationDTO
   */
  cancerType?: number;
  /**
   *
   * @type {number}
   * @memberof DeviceUsageIndicationDTO
   */
  drug?: number;
}
/**
 *
 * @export
 * @interface Drug
 */
export interface Drug {
  /**
   *
   * @type {number}
   * @memberof Drug
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  semanticType?: string;
  /**
   *
   * @type {Set<DrugBrand>}
   * @memberof Drug
   */
  brands?: Set<DrugBrand>;
}
/**
 *
 * @export
 * @interface DrugBrand
 */
export interface DrugBrand {
  /**
   *
   * @type {number}
   * @memberof DrugBrand
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof DrugBrand
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof DrugBrand
   */
  region?: DrugBrandRegionEnum;
  /**
   *
   * @type {Drug}
   * @memberof DrugBrand
   */
  drug?: Drug;
}

export const DrugBrandRegionEnum = {
  Us: 'US',
  Eu: 'EU',
} as const;

export type DrugBrandRegionEnum = typeof DrugBrandRegionEnum[keyof typeof DrugBrandRegionEnum];

/**
 *
 * @export
 * @interface DrugCriteria
 */
export interface DrugCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof DrugCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof DrugCriteria
   */
  code?: StringFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof DrugCriteria
   */
  synonymsId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof DrugCriteria
   */
  deviceUsageIndicationId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof DrugCriteria
   */
  brandsId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof DrugCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface DrugSynonym
 */
export interface DrugSynonym {
  /**
   *
   * @type {number}
   * @memberof DrugSynonym
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof DrugSynonym
   */
  name?: string;
  /**
   *
   * @type {Drug}
   * @memberof DrugSynonym
   */
  drug?: Drug;
}
/**
 *
 * @export
 * @interface EnsemblGene
 */
export interface EnsemblGene {
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  referenceGenome?: EnsemblGeneReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  ensemblGeneId: string;
  /**
   *
   * @type {boolean}
   * @memberof EnsemblGene
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  chromosome: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  start: number;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  end: number;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  strand: number;
  /**
   *
   * @type {Set<Transcript>}
   * @memberof EnsemblGene
   */
  transcripts?: Set<Transcript>;
  /**
   *
   * @type {Gene}
   * @memberof EnsemblGene
   */
  gene?: Gene;
}

export const EnsemblGeneReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type EnsemblGeneReferenceGenomeEnum = typeof EnsemblGeneReferenceGenomeEnum[keyof typeof EnsemblGeneReferenceGenomeEnum];

/**
 *
 * @export
 * @interface EnsemblTranscript
 */
export interface EnsemblTranscript {
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  transcriptId?: string;
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  geneId?: string;
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  proteinId?: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblTranscript
   */
  proteinLength?: number;
  /**
   *
   * @type {Array<PfamDomainRange>}
   * @memberof EnsemblTranscript
   */
  pfamDomains?: Array<PfamDomainRange>;
  /**
   *
   * @type {Array<string>}
   * @memberof EnsemblTranscript
   */
  hugoSymbols?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  refseqMrnaId?: string;
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  ccdsId?: string;
  /**
   *
   * @type {Array<Exon>}
   * @memberof EnsemblTranscript
   */
  exons?: Array<Exon>;
  /**
   *
   * @type {Array<UntranslatedRegion>}
   * @memberof EnsemblTranscript
   */
  utrs?: Array<UntranslatedRegion>;
}
/**
 *
 * @export
 * @interface Exon
 */
export interface Exon {
  /**
   *
   * @type {string}
   * @memberof Exon
   */
  exonId?: string;
  /**
   *
   * @type {number}
   * @memberof Exon
   */
  exonStart?: number;
  /**
   *
   * @type {number}
   * @memberof Exon
   */
  exonEnd?: number;
  /**
   *
   * @type {number}
   * @memberof Exon
   */
  rank?: number;
  /**
   *
   * @type {number}
   * @memberof Exon
   */
  strand?: number;
  /**
   *
   * @type {number}
   * @memberof Exon
   */
  version?: number;
}
/**
 *
 * @export
 * @interface FdaSubmission
 */
export interface FdaSubmission {
  /**
   *
   * @type {number}
   * @memberof FdaSubmission
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  number: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  supplementNumber?: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  deviceName: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  genericName?: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  dateReceived?: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  decisionDate?: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmission
   */
  description?: string;
  /**
   *
   * @type {boolean}
   * @memberof FdaSubmission
   */
  curated: boolean;
  /**
   *
   * @type {boolean}
   * @memberof FdaSubmission
   */
  genetic: boolean;
  /**
   *
   * @type {Set<DeviceUsageIndication>}
   * @memberof FdaSubmission
   */
  deviceUsageIndications?: Set<DeviceUsageIndication>;
  /**
   *
   * @type {CompanionDiagnosticDevice}
   * @memberof FdaSubmission
   */
  companionDiagnosticDevice: CompanionDiagnosticDevice;
  /**
   *
   * @type {FdaSubmissionType}
   * @memberof FdaSubmission
   */
  type: FdaSubmissionType;
}
/**
 *
 * @export
 * @interface FdaSubmissionCriteria
 */
export interface FdaSubmissionCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof FdaSubmissionCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof FdaSubmissionCriteria
   */
  number?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof FdaSubmissionCriteria
   */
  supplementNumber?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof FdaSubmissionCriteria
   */
  deviceName?: StringFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof FdaSubmissionCriteria
   */
  genericName?: StringFilter;
  /**
   *
   * @type {InstantFilter}
   * @memberof FdaSubmissionCriteria
   */
  dateReceived?: InstantFilter;
  /**
   *
   * @type {InstantFilter}
   * @memberof FdaSubmissionCriteria
   */
  decisionDate?: InstantFilter;
  /**
   *
   * @type {BooleanFilter}
   * @memberof FdaSubmissionCriteria
   */
  curated?: BooleanFilter;
  /**
   *
   * @type {BooleanFilter}
   * @memberof FdaSubmissionCriteria
   */
  genetic?: BooleanFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof FdaSubmissionCriteria
   */
  deviceUsageIndicationId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof FdaSubmissionCriteria
   */
  companionDiagnosticDeviceId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof FdaSubmissionCriteria
   */
  typeId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof FdaSubmissionCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface FdaSubmissionType
 */
export interface FdaSubmissionType {
  /**
   *
   * @type {number}
   * @memberof FdaSubmissionType
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof FdaSubmissionType
   */
  type: FdaSubmissionTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof FdaSubmissionType
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmissionType
   */
  shortName?: string;
  /**
   *
   * @type {string}
   * @memberof FdaSubmissionType
   */
  description?: string;
}

export const FdaSubmissionTypeTypeEnum = {
  Pma: 'PMA',
  DeNovo: 'DE_NOVO',
  Hde: 'HDE',
  Pmn: 'PMN',
} as const;

export type FdaSubmissionTypeTypeEnum = typeof FdaSubmissionTypeTypeEnum[keyof typeof FdaSubmissionTypeTypeEnum];

/**
 *
 * @export
 * @interface Gene
 */
export interface Gene {
  /**
   *
   * @type {number}
   * @memberof Gene
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof Gene
   */
  entrezGeneId?: number;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  hugoSymbol?: string;
}
/**
 *
 * @export
 * @interface GeneAlias
 */
export interface GeneAlias {
  /**
   *
   * @type {number}
   * @memberof GeneAlias
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof GeneAlias
   */
  name?: string;
  /**
   *
   * @type {Gene}
   * @memberof GeneAlias
   */
  gene?: Gene;
}
/**
 *
 * @export
 * @interface GeneCriteria
 */
export interface GeneCriteria {
  /**
   *
   * @type {LongFilter}
   * @memberof GeneCriteria
   */
  id?: LongFilter;
  /**
   *
   * @type {IntegerFilter}
   * @memberof GeneCriteria
   */
  entrezGeneId?: IntegerFilter;
  /**
   *
   * @type {StringFilter}
   * @memberof GeneCriteria
   */
  hugoSymbol?: StringFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof GeneCriteria
   */
  geneAliasId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof GeneCriteria
   */
  ensemblGeneId?: LongFilter;
  /**
   *
   * @type {LongFilter}
   * @memberof GeneCriteria
   */
  alterationId?: LongFilter;
  /**
   *
   * @type {boolean}
   * @memberof GeneCriteria
   */
  distinct?: boolean;
}
/**
 *
 * @export
 * @interface GenomeFragment
 */
export interface GenomeFragment {
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof GenomeFragment
   */
  chromosome?: string;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  end?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  strand?: number;
  /**
   *
   * @type {string}
   * @memberof GenomeFragment
   */
  type?: GenomeFragmentTypeEnum;
  /**
   *
   * @type {Transcript}
   * @memberof GenomeFragment
   */
  transcript?: Transcript;
}

export const GenomeFragmentTypeEnum = {
  Gene: 'GENE',
  Exon: 'EXON',
  FivePrimeUtr: 'FIVE_PRIME_UTR',
  ThreePrimeUtr: 'THREE_PRIME_UTR',
} as const;

export type GenomeFragmentTypeEnum = typeof GenomeFragmentTypeEnum[keyof typeof GenomeFragmentTypeEnum];

/**
 *
 * @export
 * @interface Info
 */
export interface Info {
  /**
   *
   * @type {number}
   * @memberof Info
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Info
   */
  type: InfoTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Info
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof Info
   */
  lastUpdated?: string;
}

export const InfoTypeEnum = {
  NcitVersion: 'NCIT_VERSION',
  GeneLastUpdated: 'GENE_LAST_UPDATED',
} as const;

export type InfoTypeEnum = typeof InfoTypeEnum[keyof typeof InfoTypeEnum];

/**
 *
 * @export
 * @interface InstantFilter
 */
export interface InstantFilter {
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  equals?: string;
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  notEquals?: string;
  /**
   *
   * @type {boolean}
   * @memberof InstantFilter
   */
  specified?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof InstantFilter
   */
  in?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof InstantFilter
   */
  notIn?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  greaterThan?: string;
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  lessThan?: string;
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  greaterThanOrEqual?: string;
  /**
   *
   * @type {string}
   * @memberof InstantFilter
   */
  lessThanOrEqual?: string;
}
/**
 *
 * @export
 * @interface IntegerFilter
 */
export interface IntegerFilter {
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  equals?: number;
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  notEquals?: number;
  /**
   *
   * @type {boolean}
   * @memberof IntegerFilter
   */
  specified?: boolean;
  /**
   *
   * @type {Array<number>}
   * @memberof IntegerFilter
   */
  in?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof IntegerFilter
   */
  notIn?: Array<number>;
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  greaterThan?: number;
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  lessThan?: number;
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  greaterThanOrEqual?: number;
  /**
   *
   * @type {number}
   * @memberof IntegerFilter
   */
  lessThanOrEqual?: number;
}
/**
 *
 * @export
 * @interface LongFilter
 */
export interface LongFilter {
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  equals?: number;
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  notEquals?: number;
  /**
   *
   * @type {boolean}
   * @memberof LongFilter
   */
  specified?: boolean;
  /**
   *
   * @type {Array<number>}
   * @memberof LongFilter
   */
  in?: Array<number>;
  /**
   *
   * @type {Array<number>}
   * @memberof LongFilter
   */
  notIn?: Array<number>;
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  greaterThan?: number;
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  lessThan?: number;
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  greaterThanOrEqual?: number;
  /**
   *
   * @type {number}
   * @memberof LongFilter
   */
  lessThanOrEqual?: number;
}
/**
 *
 * @export
 * @interface MatchTranscriptVM
 */
export interface MatchTranscriptVM {
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof MatchTranscriptVM
   */
  transcript?: TranscriptPairVM;
  /**
   *
   * @type {string}
   * @memberof MatchTranscriptVM
   */
  targetReferenceGenome?: MatchTranscriptVMTargetReferenceGenomeEnum;
}

export const MatchTranscriptVMTargetReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type MatchTranscriptVMTargetReferenceGenomeEnum =
  typeof MatchTranscriptVMTargetReferenceGenomeEnum[keyof typeof MatchTranscriptVMTargetReferenceGenomeEnum];

/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof Pageable
   */
  size?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Pageable
   */
  sort?: Array<string>;
}
/**
 *
 * @export
 * @interface PfamDomainRange
 */
export interface PfamDomainRange {
  /**
   *
   * @type {string}
   * @memberof PfamDomainRange
   */
  pfamDomainId?: string;
  /**
   *
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainStart?: number;
  /**
   *
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainEnd?: number;
}
/**
 *
 * @export
 * @interface SearchResultDTO
 */
export interface SearchResultDTO {
  /**
   *
   * @type {Array<FdaSubmission>}
   * @memberof SearchResultDTO
   */
  fdaSubmissions?: Array<FdaSubmission>;
  /**
   *
   * @type {Array<CompanionDiagnosticDevice>}
   * @memberof SearchResultDTO
   */
  companionDiagnosticDevices?: Array<CompanionDiagnosticDevice>;
  /**
   *
   * @type {Array<Article>}
   * @memberof SearchResultDTO
   */
  articles?: Array<Article>;
  /**
   *
   * @type {Array<Drug>}
   * @memberof SearchResultDTO
   */
  drugs?: Array<Drug>;
  /**
   *
   * @type {Array<Gene>}
   * @memberof SearchResultDTO
   */
  genes?: Array<Gene>;
  /**
   *
   * @type {Array<Alteration>}
   * @memberof SearchResultDTO
   */
  alterations?: Array<Alteration>;
}
/**
 *
 * @export
 * @interface Sequence
 */
export interface Sequence {
  /**
   *
   * @type {number}
   * @memberof Sequence
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Sequence
   */
  sequenceType?: SequenceSequenceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Sequence
   */
  sequence?: string;
  /**
   *
   * @type {Transcript}
   * @memberof Sequence
   */
  transcript?: Transcript;
}

export const SequenceSequenceTypeEnum = {
  Protein: 'PROTEIN',
  Cdna: 'CDNA',
} as const;

export type SequenceSequenceTypeEnum = typeof SequenceSequenceTypeEnum[keyof typeof SequenceSequenceTypeEnum];

/**
 *
 * @export
 * @interface SpecimenType
 */
export interface SpecimenType {
  /**
   *
   * @type {number}
   * @memberof SpecimenType
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof SpecimenType
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof SpecimenType
   */
  name: string;
  /**
   *
   * @type {Set<CompanionDiagnosticDevice>}
   * @memberof SpecimenType
   */
  companionDiagnosticDevices?: Set<CompanionDiagnosticDevice>;
}
/**
 *
 * @export
 * @interface StringFilter
 */
export interface StringFilter {
  /**
   *
   * @type {string}
   * @memberof StringFilter
   */
  equals?: string;
  /**
   *
   * @type {string}
   * @memberof StringFilter
   */
  notEquals?: string;
  /**
   *
   * @type {boolean}
   * @memberof StringFilter
   */
  specified?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof StringFilter
   */
  in?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof StringFilter
   */
  notIn?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof StringFilter
   */
  contains?: string;
  /**
   *
   * @type {string}
   * @memberof StringFilter
   */
  doesNotContain?: string;
}
/**
 *
 * @export
 * @interface Transcript
 */
export interface Transcript {
  /**
   *
   * @type {number}
   * @memberof Transcript
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  ensemblTranscriptId?: string;
  /**
   *
   * @type {boolean}
   * @memberof Transcript
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  ensemblProteinId?: string;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  referenceSequenceId?: string;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  description?: string;
  /**
   *
   * @type {Set<GenomeFragment>}
   * @memberof Transcript
   */
  fragments?: Set<GenomeFragment>;
  /**
   *
   * @type {Set<Sequence>}
   * @memberof Transcript
   */
  sequences?: Set<Sequence>;
  /**
   *
   * @type {EnsemblGene}
   * @memberof Transcript
   */
  ensemblGene?: EnsemblGene;
}
/**
 *
 * @export
 * @interface TranscriptComparisonResultVM
 */
export interface TranscriptComparisonResultVM {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptComparisonResultVM
   */
  match?: boolean;
  /**
   *
   * @type {string}
   * @memberof TranscriptComparisonResultVM
   */
  sequenceA?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptComparisonResultVM
   */
  sequenceB?: string;
}
/**
 *
 * @export
 * @interface TranscriptComparisonVM
 */
export interface TranscriptComparisonVM {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptComparisonVM
   */
  align?: boolean;
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof TranscriptComparisonVM
   */
  transcriptA?: TranscriptPairVM;
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof TranscriptComparisonVM
   */
  transcriptB?: TranscriptPairVM;
}
/**
 *
 * @export
 * @interface TranscriptDTO
 */
export interface TranscriptDTO {
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  ensemblTranscriptId?: string;
  /**
   *
   * @type {boolean}
   * @memberof TranscriptDTO
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  ensemblProteinId?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  referenceSequenceId?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  description?: string;
  /**
   *
   * @type {EnsemblGene}
   * @memberof TranscriptDTO
   */
  ensemblGene?: EnsemblGene;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  strand?: number;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  chromosome?: string;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  end?: number;
  /**
   *
   * @type {Array<GenomeFragment>}
   * @memberof TranscriptDTO
   */
  exons?: Array<GenomeFragment>;
  /**
   *
   * @type {Array<GenomeFragment>}
   * @memberof TranscriptDTO
   */
  utrs?: Array<GenomeFragment>;
}
/**
 *
 * @export
 * @interface TranscriptMatchResultVM
 */
export interface TranscriptMatchResultVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptMatchResultVM
   */
  note?: string;
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptMatchResultVM
   */
  originalEnsemblTranscript?: EnsemblTranscript;
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptMatchResultVM
   */
  targetEnsemblTranscript?: EnsemblTranscript;
}
/**
 *
 * @export
 * @interface TranscriptPairVM
 */
export interface TranscriptPairVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptPairVM
   */
  referenceGenome?: TranscriptPairVMReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof TranscriptPairVM
   */
  transcript?: string;
}

export const TranscriptPairVMReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type TranscriptPairVMReferenceGenomeEnum =
  typeof TranscriptPairVMReferenceGenomeEnum[keyof typeof TranscriptPairVMReferenceGenomeEnum];

/**
 *
 * @export
 * @interface TranscriptSuggestionVM
 */
export interface TranscriptSuggestionVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptSuggestionVM
   */
  referenceGenome?: TranscriptSuggestionVMReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof TranscriptSuggestionVM
   */
  note?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TranscriptSuggestionVM
   */
  suggestions?: Array<string>;
}

export const TranscriptSuggestionVMReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type TranscriptSuggestionVMReferenceGenomeEnum =
  typeof TranscriptSuggestionVMReferenceGenomeEnum[keyof typeof TranscriptSuggestionVMReferenceGenomeEnum];

/**
 *
 * @export
 * @interface UntranslatedRegion
 */
export interface UntranslatedRegion {
  /**
   *
   * @type {string}
   * @memberof UntranslatedRegion
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof UntranslatedRegion
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof UntranslatedRegion
   */
  end?: number;
  /**
   *
   * @type {number}
   * @memberof UntranslatedRegion
   */
  strand?: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  login: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  activated: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  langKey?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  imageUrl?: string;
}
/**
 *
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
  /**
   *
   * @type {number}
   * @memberof UserDTO
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  login: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  imageUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserDTO
   */
  activated?: boolean;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  langKey?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  createdDate?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastModifiedBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastModifiedDate?: string;
  /**
   *
   * @type {Set<string>}
   * @memberof UserDTO
   */
  authorities?: Set<string>;
}

/**
 * AccountResourceApi - axios parameter creator
 * @export
 */
export const AccountResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAuthenticated: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/authenticate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountResourceApi - functional programming interface
 * @export
 */
export const AccountResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isAuthenticated(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isAuthenticated(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AccountResourceApi - factory interface
 * @export
 */
export const AccountResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AccountResourceApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(options?: any): AxiosPromise<UserDTO> {
      return localVarFp.getAccount(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAuthenticated(options?: any): AxiosPromise<string> {
      return localVarFp.isAuthenticated(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AccountResourceApi - object-oriented interface
 * @export
 * @class AccountResourceApi
 * @extends {BaseAPI}
 */
export class AccountResourceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountResourceApi
   */
  public getAccount(options?: AxiosRequestConfig) {
    return AccountResourceApiFp(this.configuration)
      .getAccount(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountResourceApi
   */
  public isAuthenticated(options?: AxiosRequestConfig) {
    return AccountResourceApiFp(this.configuration)
      .isAuthenticated(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AlterationControllerApi - axios parameter creator
 * @export
 */
export const AlterationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotateAlteration: async (alteration: Alteration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'alteration' is not null or undefined
      assertParamExists('annotateAlteration', 'alteration', alteration);
      const localVarPath = `/api/annotate-alteration`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(alteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlterationControllerApi - functional programming interface
 * @export
 */
export const AlterationControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlterationControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async annotateAlteration(
      alteration: Alteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.annotateAlteration(alteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AlterationControllerApi - factory interface
 * @export
 */
export const AlterationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AlterationControllerApiFp(configuration);
  return {
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    annotateAlteration(alteration: Alteration, options?: any): AxiosPromise<Alteration> {
      return localVarFp.annotateAlteration(alteration, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AlterationControllerApi - object-oriented interface
 * @export
 * @class AlterationControllerApi
 * @extends {BaseAPI}
 */
export class AlterationControllerApi extends BaseAPI {
  /**
   *
   * @param {Alteration} alteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationControllerApi
   */
  public annotateAlteration(alteration: Alteration, options?: AxiosRequestConfig) {
    return AlterationControllerApiFp(this.configuration)
      .annotateAlteration(alteration, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AlterationResourceApi - axios parameter creator
 * @export
 */
export const AlterationResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countAlterations: async (criteria: AlterationCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countAlterations', 'criteria', criteria);
      const localVarPath = `/api/alterations/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlteration: async (alteration: Alteration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'alteration' is not null or undefined
      assertParamExists('createAlteration', 'alteration', alteration);
      const localVarPath = `/api/alterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(alteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlteration: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAlteration', 'id', id);
      const localVarPath = `/api/alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByGeneId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('findByGeneId', 'id', id);
      const localVarPath = `/api/alterations/gene/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAlterations: async (criteria: AlterationCriteria, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllAlterations', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllAlterations', 'pageable', pageable);
      const localVarPath = `/api/alterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlteration: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAlteration', 'id', id);
      const localVarPath = `/api/alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateAlteration: async (id: number, alteration: Alteration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateAlteration', 'id', id);
      // verify required parameter 'alteration' is not null or undefined
      assertParamExists('partialUpdateAlteration', 'alteration', alteration);
      const localVarPath = `/api/alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(alteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAlterations: async (query: string, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchAlterations', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchAlterations', 'pageable', pageable);
      const localVarPath = `/api/_search/alterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlteration: async (id: number, alteration: Alteration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateAlteration', 'id', id);
      // verify required parameter 'alteration' is not null or undefined
      assertParamExists('updateAlteration', 'alteration', alteration);
      const localVarPath = `/api/alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(alteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlterationResourceApi - functional programming interface
 * @export
 */
export const AlterationResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlterationResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countAlterations(
      criteria: AlterationCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countAlterations(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAlteration(
      alteration: Alteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAlteration(alteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAlteration(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlteration(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findByGeneId(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findByGeneId(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllAlterations(
      criteria: AlterationCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlterations(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAlteration(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAlteration(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateAlteration(
      id: number,
      alteration: Alteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAlteration(id, alteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAlterations(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchAlterations(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAlteration(
      id: number,
      alteration: Alteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlteration(id, alteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AlterationResourceApi - factory interface
 * @export
 */
export const AlterationResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AlterationResourceApiFp(configuration);
  return {
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countAlterations(criteria: AlterationCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countAlterations(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlteration(alteration: Alteration, options?: any): AxiosPromise<Alteration> {
      return localVarFp.createAlteration(alteration, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlteration(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteAlteration(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByGeneId(id: number, options?: any): AxiosPromise<Array<Alteration>> {
      return localVarFp.findByGeneId(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {AlterationCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllAlterations(criteria: AlterationCriteria, pageable: Pageable, options?: any): AxiosPromise<Array<Alteration>> {
      return localVarFp.getAllAlterations(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlteration(id: number, options?: any): AxiosPromise<Alteration> {
      return localVarFp.getAlteration(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateAlteration(id: number, alteration: Alteration, options?: any): AxiosPromise<Alteration> {
      return localVarFp.partialUpdateAlteration(id, alteration, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAlterations(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<Alteration>> {
      return localVarFp.searchAlterations(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Alteration} alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlteration(id: number, alteration: Alteration, options?: any): AxiosPromise<Alteration> {
      return localVarFp.updateAlteration(id, alteration, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AlterationResourceApi - object-oriented interface
 * @export
 * @class AlterationResourceApi
 * @extends {BaseAPI}
 */
export class AlterationResourceApi extends BaseAPI {
  /**
   *
   * @param {AlterationCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public countAlterations(criteria: AlterationCriteria, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .countAlterations(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Alteration} alteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public createAlteration(alteration: Alteration, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .createAlteration(alteration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public deleteAlteration(id: number, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .deleteAlteration(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public findByGeneId(id: number, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .findByGeneId(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {AlterationCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public getAllAlterations(criteria: AlterationCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .getAllAlterations(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public getAlteration(id: number, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .getAlteration(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Alteration} alteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public partialUpdateAlteration(id: number, alteration: Alteration, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .partialUpdateAlteration(id, alteration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public searchAlterations(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .searchAlterations(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Alteration} alteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlterationResourceApi
   */
  public updateAlteration(id: number, alteration: Alteration, options?: AxiosRequestConfig) {
    return AlterationResourceApiFp(this.configuration)
      .updateAlteration(id, alteration, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ArticleResourceApi - axios parameter creator
 * @export
 */
export const ArticleResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countArticles: async (criteria: ArticleCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countArticles', 'criteria', criteria);
      const localVarPath = `/api/articles/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticle: async (article: Article, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'article' is not null or undefined
      assertParamExists('createArticle', 'article', article);
      const localVarPath = `/api/articles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(article, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticle: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteArticle', 'id', id);
      const localVarPath = `/api/articles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArticles: async (criteria: ArticleCriteria, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllArticles', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllArticles', 'pageable', pageable);
      const localVarPath = `/api/articles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticle: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getArticle', 'id', id);
      const localVarPath = `/api/articles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateArticle: async (id: number, article: Article, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateArticle', 'id', id);
      // verify required parameter 'article' is not null or undefined
      assertParamExists('partialUpdateArticle', 'article', article);
      const localVarPath = `/api/articles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(article, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchArticles: async (query: string, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchArticles', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchArticles', 'pageable', pageable);
      const localVarPath = `/api/_search/articles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle: async (id: number, article: Article, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateArticle', 'id', id);
      // verify required parameter 'article' is not null or undefined
      assertParamExists('updateArticle', 'article', article);
      const localVarPath = `/api/articles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(article, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ArticleResourceApi - functional programming interface
 * @export
 */
export const ArticleResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ArticleResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countArticles(
      criteria: ArticleCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countArticles(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createArticle(
      article: Article,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createArticle(article, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteArticle(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArticle(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllArticles(
      criteria: ArticleCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Article>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllArticles(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getArticle(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getArticle(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateArticle(
      id: number,
      article: Article,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateArticle(id, article, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchArticles(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Article>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchArticles(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateArticle(
      id: number,
      article: Article,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Article>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateArticle(id, article, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ArticleResourceApi - factory interface
 * @export
 */
export const ArticleResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ArticleResourceApiFp(configuration);
  return {
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countArticles(criteria: ArticleCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countArticles(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArticle(article: Article, options?: any): AxiosPromise<Article> {
      return localVarFp.createArticle(article, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArticle(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteArticle(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ArticleCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArticles(criteria: ArticleCriteria, pageable: Pageable, options?: any): AxiosPromise<Array<Article>> {
      return localVarFp.getAllArticles(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArticle(id: number, options?: any): AxiosPromise<Article> {
      return localVarFp.getArticle(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateArticle(id: number, article: Article, options?: any): AxiosPromise<Article> {
      return localVarFp.partialUpdateArticle(id, article, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchArticles(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<Article>> {
      return localVarFp.searchArticles(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Article} article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(id: number, article: Article, options?: any): AxiosPromise<Article> {
      return localVarFp.updateArticle(id, article, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ArticleResourceApi - object-oriented interface
 * @export
 * @class ArticleResourceApi
 * @extends {BaseAPI}
 */
export class ArticleResourceApi extends BaseAPI {
  /**
   *
   * @param {ArticleCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public countArticles(criteria: ArticleCriteria, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .countArticles(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Article} article
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public createArticle(article: Article, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .createArticle(article, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public deleteArticle(id: number, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .deleteArticle(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ArticleCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public getAllArticles(criteria: ArticleCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .getAllArticles(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public getArticle(id: number, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .getArticle(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Article} article
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public partialUpdateArticle(id: number, article: Article, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .partialUpdateArticle(id, article, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public searchArticles(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .searchArticles(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Article} article
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleResourceApi
   */
  public updateArticle(id: number, article: Article, options?: AxiosRequestConfig) {
    return ArticleResourceApiFp(this.configuration)
      .updateArticle(id, article, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AuthInfoResourceApi - axios parameter creator
 * @export
 */
export const AuthInfoResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth-info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthInfoResourceApi - functional programming interface
 * @export
 */
export const AuthInfoResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthInfoResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfoVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthInfoResourceApi - factory interface
 * @export
 */
export const AuthInfoResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthInfoResourceApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthInfo(options?: any): AxiosPromise<AuthInfoVM> {
      return localVarFp.getAuthInfo(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AuthInfoResourceApi - object-oriented interface
 * @export
 * @class AuthInfoResourceApi
 * @extends {BaseAPI}
 */
export class AuthInfoResourceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthInfoResourceApi
   */
  public getAuthInfo(options?: AxiosRequestConfig) {
    return AuthInfoResourceApiFp(this.configuration)
      .getAuthInfo(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CancerTypeResourceApi - axios parameter creator
 * @export
 */
export const CancerTypeResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCancerType: async (cancerType: CancerType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'cancerType' is not null or undefined
      assertParamExists('createCancerType', 'cancerType', cancerType);
      const localVarPath = `/api/cancer-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cancerType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCancerType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteCancerType', 'id', id);
      const localVarPath = `/api/cancer-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCancerTypes: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllCancerTypes', 'pageable', pageable);
      const localVarPath = `/api/cancer-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCancerType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCancerType', 'id', id);
      const localVarPath = `/api/cancer-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCancerType: async (id: number, cancerType: CancerType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateCancerType', 'id', id);
      // verify required parameter 'cancerType' is not null or undefined
      assertParamExists('partialUpdateCancerType', 'cancerType', cancerType);
      const localVarPath = `/api/cancer-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cancerType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCancerType: async (id: number, cancerType: CancerType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateCancerType', 'id', id);
      // verify required parameter 'cancerType' is not null or undefined
      assertParamExists('updateCancerType', 'cancerType', cancerType);
      const localVarPath = `/api/cancer-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cancerType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CancerTypeResourceApi - functional programming interface
 * @export
 */
export const CancerTypeResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CancerTypeResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCancerType(
      cancerType: CancerType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancerType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCancerType(cancerType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCancerType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCancerType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllCancerTypes(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CancerType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCancerTypes(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCancerType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancerType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCancerType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateCancerType(
      id: number,
      cancerType: CancerType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancerType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCancerType(id, cancerType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCancerType(
      id: number,
      cancerType: CancerType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancerType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCancerType(id, cancerType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CancerTypeResourceApi - factory interface
 * @export
 */
export const CancerTypeResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CancerTypeResourceApiFp(configuration);
  return {
    /**
     *
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCancerType(cancerType: CancerType, options?: any): AxiosPromise<CancerType> {
      return localVarFp.createCancerType(cancerType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCancerType(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteCancerType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCancerTypes(pageable: Pageable, options?: any): AxiosPromise<Array<CancerType>> {
      return localVarFp.getAllCancerTypes(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCancerType(id: number, options?: any): AxiosPromise<CancerType> {
      return localVarFp.getCancerType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCancerType(id: number, cancerType: CancerType, options?: any): AxiosPromise<CancerType> {
      return localVarFp.partialUpdateCancerType(id, cancerType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CancerType} cancerType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCancerType(id: number, cancerType: CancerType, options?: any): AxiosPromise<CancerType> {
      return localVarFp.updateCancerType(id, cancerType, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CancerTypeResourceApi - object-oriented interface
 * @export
 * @class CancerTypeResourceApi
 * @extends {BaseAPI}
 */
export class CancerTypeResourceApi extends BaseAPI {
  /**
   *
   * @param {CancerType} cancerType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public createCancerType(cancerType: CancerType, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .createCancerType(cancerType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public deleteCancerType(id: number, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .deleteCancerType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public getAllCancerTypes(pageable: Pageable, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .getAllCancerTypes(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public getCancerType(id: number, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .getCancerType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CancerType} cancerType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public partialUpdateCancerType(id: number, cancerType: CancerType, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .partialUpdateCancerType(id, cancerType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CancerType} cancerType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CancerTypeResourceApi
   */
  public updateCancerType(id: number, cancerType: CancerType, options?: AxiosRequestConfig) {
    return CancerTypeResourceApiFp(this.configuration)
      .updateCancerType(id, cancerType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CategoricalAlterationResourceApi - axios parameter creator
 * @export
 */
export const CategoricalAlterationResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategoricalAlteration: async (
      categoricalAlteration: CategoricalAlteration,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'categoricalAlteration' is not null or undefined
      assertParamExists('createCategoricalAlteration', 'categoricalAlteration', categoricalAlteration);
      const localVarPath = `/api/categorical-alterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(categoricalAlteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategoricalAlteration: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteCategoricalAlteration', 'id', id);
      const localVarPath = `/api/categorical-alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategoricalAlterations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/categorical-alterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategoricalAlteration: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCategoricalAlteration', 'id', id);
      const localVarPath = `/api/categorical-alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCategoricalAlteration: async (
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateCategoricalAlteration', 'id', id);
      // verify required parameter 'categoricalAlteration' is not null or undefined
      assertParamExists('partialUpdateCategoricalAlteration', 'categoricalAlteration', categoricalAlteration);
      const localVarPath = `/api/categorical-alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(categoricalAlteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategoricalAlteration: async (
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateCategoricalAlteration', 'id', id);
      // verify required parameter 'categoricalAlteration' is not null or undefined
      assertParamExists('updateCategoricalAlteration', 'categoricalAlteration', categoricalAlteration);
      const localVarPath = `/api/categorical-alterations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(categoricalAlteration, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoricalAlterationResourceApi - functional programming interface
 * @export
 */
export const CategoricalAlterationResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CategoricalAlterationResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCategoricalAlteration(
      categoricalAlteration: CategoricalAlteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoricalAlteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCategoricalAlteration(categoricalAlteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCategoricalAlteration(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoricalAlteration(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllCategoricalAlterations(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoricalAlteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategoricalAlterations(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCategoricalAlteration(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoricalAlteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoricalAlteration(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateCategoricalAlteration(
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoricalAlteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCategoricalAlteration(id, categoricalAlteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCategoricalAlteration(
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoricalAlteration>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategoricalAlteration(id, categoricalAlteration, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CategoricalAlterationResourceApi - factory interface
 * @export
 */
export const CategoricalAlterationResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CategoricalAlterationResourceApiFp(configuration);
  return {
    /**
     *
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategoricalAlteration(categoricalAlteration: CategoricalAlteration, options?: any): AxiosPromise<CategoricalAlteration> {
      return localVarFp.createCategoricalAlteration(categoricalAlteration, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategoricalAlteration(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteCategoricalAlteration(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCategoricalAlterations(options?: any): AxiosPromise<Array<CategoricalAlteration>> {
      return localVarFp.getAllCategoricalAlterations(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategoricalAlteration(id: number, options?: any): AxiosPromise<CategoricalAlteration> {
      return localVarFp.getCategoricalAlteration(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCategoricalAlteration(
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options?: any
    ): AxiosPromise<CategoricalAlteration> {
      return localVarFp.partialUpdateCategoricalAlteration(id, categoricalAlteration, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CategoricalAlteration} categoricalAlteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategoricalAlteration(
      id: number,
      categoricalAlteration: CategoricalAlteration,
      options?: any
    ): AxiosPromise<CategoricalAlteration> {
      return localVarFp.updateCategoricalAlteration(id, categoricalAlteration, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CategoricalAlterationResourceApi - object-oriented interface
 * @export
 * @class CategoricalAlterationResourceApi
 * @extends {BaseAPI}
 */
export class CategoricalAlterationResourceApi extends BaseAPI {
  /**
   *
   * @param {CategoricalAlteration} categoricalAlteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public createCategoricalAlteration(categoricalAlteration: CategoricalAlteration, options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .createCategoricalAlteration(categoricalAlteration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public deleteCategoricalAlteration(id: number, options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .deleteCategoricalAlteration(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public getAllCategoricalAlterations(options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .getAllCategoricalAlterations(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public getCategoricalAlteration(id: number, options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .getCategoricalAlteration(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CategoricalAlteration} categoricalAlteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public partialUpdateCategoricalAlteration(id: number, categoricalAlteration: CategoricalAlteration, options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .partialUpdateCategoricalAlteration(id, categoricalAlteration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CategoricalAlteration} categoricalAlteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoricalAlterationResourceApi
   */
  public updateCategoricalAlteration(id: number, categoricalAlteration: CategoricalAlteration, options?: AxiosRequestConfig) {
    return CategoricalAlterationResourceApiFp(this.configuration)
      .updateCategoricalAlteration(id, categoricalAlteration, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ClinicalTrialsGovConditionResourceApi - axios parameter creator
 * @export
 */
export const ClinicalTrialsGovConditionResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countClinicalTrialsGovConditions: async (
      criteria: ClinicalTrialsGovConditionCriteria,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countClinicalTrialsGovConditions', 'criteria', criteria);
      const localVarPath = `/api/clinical-trials-gov-conditions/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClinicalTrialsGovCondition: async (
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'clinicalTrialsGovCondition' is not null or undefined
      assertParamExists('createClinicalTrialsGovCondition', 'clinicalTrialsGovCondition', clinicalTrialsGovCondition);
      const localVarPath = `/api/clinical-trials-gov-conditions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(clinicalTrialsGovCondition, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClinicalTrialsGovCondition: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteClinicalTrialsGovCondition', 'id', id);
      const localVarPath = `/api/clinical-trials-gov-conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClinicalTrialsGovConditions: async (
      criteria: ClinicalTrialsGovConditionCriteria,
      pageable: Pageable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllClinicalTrialsGovConditions', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllClinicalTrialsGovConditions', 'pageable', pageable);
      const localVarPath = `/api/clinical-trials-gov-conditions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinicalTrialsGovCondition: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getClinicalTrialsGovCondition', 'id', id);
      const localVarPath = `/api/clinical-trials-gov-conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateClinicalTrialsGovCondition: async (
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateClinicalTrialsGovCondition', 'id', id);
      // verify required parameter 'clinicalTrialsGovCondition' is not null or undefined
      assertParamExists('partialUpdateClinicalTrialsGovCondition', 'clinicalTrialsGovCondition', clinicalTrialsGovCondition);
      const localVarPath = `/api/clinical-trials-gov-conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(clinicalTrialsGovCondition, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchClinicalTrialsGovConditions: async (
      query: string,
      pageable: Pageable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchClinicalTrialsGovConditions', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchClinicalTrialsGovConditions', 'pageable', pageable);
      const localVarPath = `/api/_search/clinical-trials-gov-conditions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClinicalTrialsGovCondition: async (
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateClinicalTrialsGovCondition', 'id', id);
      // verify required parameter 'clinicalTrialsGovCondition' is not null or undefined
      assertParamExists('updateClinicalTrialsGovCondition', 'clinicalTrialsGovCondition', clinicalTrialsGovCondition);
      const localVarPath = `/api/clinical-trials-gov-conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(clinicalTrialsGovCondition, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClinicalTrialsGovConditionResourceApi - functional programming interface
 * @export
 */
export const ClinicalTrialsGovConditionResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClinicalTrialsGovConditionResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countClinicalTrialsGovConditions(
      criteria: ClinicalTrialsGovConditionCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countClinicalTrialsGovConditions(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createClinicalTrialsGovCondition(
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClinicalTrialsGovCondition>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createClinicalTrialsGovCondition(clinicalTrialsGovCondition, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClinicalTrialsGovCondition(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClinicalTrialsGovCondition(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllClinicalTrialsGovConditions(
      criteria: ClinicalTrialsGovConditionCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinicalTrialsGovCondition>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllClinicalTrialsGovConditions(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClinicalTrialsGovCondition(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClinicalTrialsGovCondition>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClinicalTrialsGovCondition(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateClinicalTrialsGovCondition(
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClinicalTrialsGovCondition>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateClinicalTrialsGovCondition(
        id,
        clinicalTrialsGovCondition,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchClinicalTrialsGovConditions(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinicalTrialsGovCondition>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchClinicalTrialsGovConditions(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateClinicalTrialsGovCondition(
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClinicalTrialsGovCondition>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateClinicalTrialsGovCondition(id, clinicalTrialsGovCondition, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ClinicalTrialsGovConditionResourceApi - factory interface
 * @export
 */
export const ClinicalTrialsGovConditionResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClinicalTrialsGovConditionResourceApiFp(configuration);
  return {
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countClinicalTrialsGovConditions(criteria: ClinicalTrialsGovConditionCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countClinicalTrialsGovConditions(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClinicalTrialsGovCondition(
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: any
    ): AxiosPromise<ClinicalTrialsGovCondition> {
      return localVarFp.createClinicalTrialsGovCondition(clinicalTrialsGovCondition, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClinicalTrialsGovCondition(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteClinicalTrialsGovCondition(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ClinicalTrialsGovConditionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClinicalTrialsGovConditions(
      criteria: ClinicalTrialsGovConditionCriteria,
      pageable: Pageable,
      options?: any
    ): AxiosPromise<Array<ClinicalTrialsGovCondition>> {
      return localVarFp.getAllClinicalTrialsGovConditions(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClinicalTrialsGovCondition(id: number, options?: any): AxiosPromise<ClinicalTrialsGovCondition> {
      return localVarFp.getClinicalTrialsGovCondition(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateClinicalTrialsGovCondition(
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: any
    ): AxiosPromise<ClinicalTrialsGovCondition> {
      return localVarFp
        .partialUpdateClinicalTrialsGovCondition(id, clinicalTrialsGovCondition, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchClinicalTrialsGovConditions(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<ClinicalTrialsGovCondition>> {
      return localVarFp.searchClinicalTrialsGovConditions(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClinicalTrialsGovCondition(
      id: number,
      clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
      options?: any
    ): AxiosPromise<ClinicalTrialsGovCondition> {
      return localVarFp.updateClinicalTrialsGovCondition(id, clinicalTrialsGovCondition, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ClinicalTrialsGovConditionResourceApi - object-oriented interface
 * @export
 * @class ClinicalTrialsGovConditionResourceApi
 * @extends {BaseAPI}
 */
export class ClinicalTrialsGovConditionResourceApi extends BaseAPI {
  /**
   *
   * @param {ClinicalTrialsGovConditionCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public countClinicalTrialsGovConditions(criteria: ClinicalTrialsGovConditionCriteria, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .countClinicalTrialsGovConditions(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public createClinicalTrialsGovCondition(clinicalTrialsGovCondition: ClinicalTrialsGovCondition, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .createClinicalTrialsGovCondition(clinicalTrialsGovCondition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public deleteClinicalTrialsGovCondition(id: number, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .deleteClinicalTrialsGovCondition(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ClinicalTrialsGovConditionCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public getAllClinicalTrialsGovConditions(criteria: ClinicalTrialsGovConditionCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .getAllClinicalTrialsGovConditions(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public getClinicalTrialsGovCondition(id: number, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .getClinicalTrialsGovCondition(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public partialUpdateClinicalTrialsGovCondition(
    id: number,
    clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
    options?: AxiosRequestConfig
  ) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .partialUpdateClinicalTrialsGovCondition(id, clinicalTrialsGovCondition, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public searchClinicalTrialsGovConditions(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .searchClinicalTrialsGovConditions(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {ClinicalTrialsGovCondition} clinicalTrialsGovCondition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClinicalTrialsGovConditionResourceApi
   */
  public updateClinicalTrialsGovCondition(
    id: number,
    clinicalTrialsGovCondition: ClinicalTrialsGovCondition,
    options?: AxiosRequestConfig
  ) {
    return ClinicalTrialsGovConditionResourceApiFp(this.configuration)
      .updateClinicalTrialsGovCondition(id, clinicalTrialsGovCondition, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CompanionDiagnosticDeviceResourceApi - axios parameter creator
 * @export
 */
export const CompanionDiagnosticDeviceResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCompanionDiagnosticDevices: async (
      criteria: CompanionDiagnosticDeviceCriteria,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countCompanionDiagnosticDevices', 'criteria', criteria);
      const localVarPath = `/api/companion-diagnostic-devices/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCompanionDiagnosticDevice: async (
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'companionDiagnosticDevice' is not null or undefined
      assertParamExists('createCompanionDiagnosticDevice', 'companionDiagnosticDevice', companionDiagnosticDevice);
      const localVarPath = `/api/companion-diagnostic-devices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(companionDiagnosticDevice, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompanionDiagnosticDevice: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteCompanionDiagnosticDevice', 'id', id);
      const localVarPath = `/api/companion-diagnostic-devices/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCompanionDiagnosticDevices: async (
      criteria: CompanionDiagnosticDeviceCriteria,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllCompanionDiagnosticDevices', 'criteria', criteria);
      const localVarPath = `/api/companion-diagnostic-devices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanionDiagnosticDevice: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCompanionDiagnosticDevice', 'id', id);
      const localVarPath = `/api/companion-diagnostic-devices/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCompanionDiagnosticDevice: async (
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateCompanionDiagnosticDevice', 'id', id);
      // verify required parameter 'companionDiagnosticDevice' is not null or undefined
      assertParamExists('partialUpdateCompanionDiagnosticDevice', 'companionDiagnosticDevice', companionDiagnosticDevice);
      const localVarPath = `/api/companion-diagnostic-devices/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(companionDiagnosticDevice, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCompanionDiagnosticDevices: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchCompanionDiagnosticDevices', 'query', query);
      const localVarPath = `/api/_search/companion-diagnostic-devices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanionDiagnosticDevice: async (
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateCompanionDiagnosticDevice', 'id', id);
      // verify required parameter 'companionDiagnosticDevice' is not null or undefined
      assertParamExists('updateCompanionDiagnosticDevice', 'companionDiagnosticDevice', companionDiagnosticDevice);
      const localVarPath = `/api/companion-diagnostic-devices/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(companionDiagnosticDevice, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompanionDiagnosticDeviceResourceApi - functional programming interface
 * @export
 */
export const CompanionDiagnosticDeviceResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CompanionDiagnosticDeviceResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countCompanionDiagnosticDevices(
      criteria: CompanionDiagnosticDeviceCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countCompanionDiagnosticDevices(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCompanionDiagnosticDevice(
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanionDiagnosticDevice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCompanionDiagnosticDevice(companionDiagnosticDevice, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCompanionDiagnosticDevice(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompanionDiagnosticDevice(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllCompanionDiagnosticDevices(
      criteria: CompanionDiagnosticDeviceCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanionDiagnosticDevice>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCompanionDiagnosticDevices(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompanionDiagnosticDevice(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanionDiagnosticDevice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanionDiagnosticDevice(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateCompanionDiagnosticDevice(
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanionDiagnosticDevice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCompanionDiagnosticDevice(
        id,
        companionDiagnosticDevice,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCompanionDiagnosticDevices(
      query: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanionDiagnosticDevice>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchCompanionDiagnosticDevices(query, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCompanionDiagnosticDevice(
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanionDiagnosticDevice>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanionDiagnosticDevice(id, companionDiagnosticDevice, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CompanionDiagnosticDeviceResourceApi - factory interface
 * @export
 */
export const CompanionDiagnosticDeviceResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanionDiagnosticDeviceResourceApiFp(configuration);
  return {
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCompanionDiagnosticDevices(criteria: CompanionDiagnosticDeviceCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countCompanionDiagnosticDevices(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCompanionDiagnosticDevice(
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: any
    ): AxiosPromise<CompanionDiagnosticDevice> {
      return localVarFp.createCompanionDiagnosticDevice(companionDiagnosticDevice, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompanionDiagnosticDevice(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteCompanionDiagnosticDevice(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {CompanionDiagnosticDeviceCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCompanionDiagnosticDevices(
      criteria: CompanionDiagnosticDeviceCriteria,
      options?: any
    ): AxiosPromise<Array<CompanionDiagnosticDevice>> {
      return localVarFp.getAllCompanionDiagnosticDevices(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanionDiagnosticDevice(id: number, options?: any): AxiosPromise<CompanionDiagnosticDevice> {
      return localVarFp.getCompanionDiagnosticDevice(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateCompanionDiagnosticDevice(
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: any
    ): AxiosPromise<CompanionDiagnosticDevice> {
      return localVarFp
        .partialUpdateCompanionDiagnosticDevice(id, companionDiagnosticDevice, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCompanionDiagnosticDevices(query: string, options?: any): AxiosPromise<Array<CompanionDiagnosticDevice>> {
      return localVarFp.searchCompanionDiagnosticDevices(query, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanionDiagnosticDevice(
      id: number,
      companionDiagnosticDevice: CompanionDiagnosticDevice,
      options?: any
    ): AxiosPromise<CompanionDiagnosticDevice> {
      return localVarFp.updateCompanionDiagnosticDevice(id, companionDiagnosticDevice, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CompanionDiagnosticDeviceResourceApi - object-oriented interface
 * @export
 * @class CompanionDiagnosticDeviceResourceApi
 * @extends {BaseAPI}
 */
export class CompanionDiagnosticDeviceResourceApi extends BaseAPI {
  /**
   *
   * @param {CompanionDiagnosticDeviceCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public countCompanionDiagnosticDevices(criteria: CompanionDiagnosticDeviceCriteria, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .countCompanionDiagnosticDevices(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public createCompanionDiagnosticDevice(companionDiagnosticDevice: CompanionDiagnosticDevice, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .createCompanionDiagnosticDevice(companionDiagnosticDevice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public deleteCompanionDiagnosticDevice(id: number, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .deleteCompanionDiagnosticDevice(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CompanionDiagnosticDeviceCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public getAllCompanionDiagnosticDevices(criteria: CompanionDiagnosticDeviceCriteria, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .getAllCompanionDiagnosticDevices(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public getCompanionDiagnosticDevice(id: number, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .getCompanionDiagnosticDevice(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public partialUpdateCompanionDiagnosticDevice(
    id: number,
    companionDiagnosticDevice: CompanionDiagnosticDevice,
    options?: AxiosRequestConfig
  ) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .partialUpdateCompanionDiagnosticDevice(id, companionDiagnosticDevice, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public searchCompanionDiagnosticDevices(query: string, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .searchCompanionDiagnosticDevices(query, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {CompanionDiagnosticDevice} companionDiagnosticDevice
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanionDiagnosticDeviceResourceApi
   */
  public updateCompanionDiagnosticDevice(id: number, companionDiagnosticDevice: CompanionDiagnosticDevice, options?: AxiosRequestConfig) {
    return CompanionDiagnosticDeviceResourceApiFp(this.configuration)
      .updateCompanionDiagnosticDevice(id, companionDiagnosticDevice, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ConsequenceResourceApi - axios parameter creator
 * @export
 */
export const ConsequenceResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConsequence: async (consequence: Consequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'consequence' is not null or undefined
      assertParamExists('createConsequence', 'consequence', consequence);
      const localVarPath = `/api/consequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(consequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConsequence: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteConsequence', 'id', id);
      const localVarPath = `/api/consequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllConsequences: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/consequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConsequence: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getConsequence', 'id', id);
      const localVarPath = `/api/consequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateConsequence: async (id: number, consequence: Consequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateConsequence', 'id', id);
      // verify required parameter 'consequence' is not null or undefined
      assertParamExists('partialUpdateConsequence', 'consequence', consequence);
      const localVarPath = `/api/consequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(consequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConsequence: async (id: number, consequence: Consequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateConsequence', 'id', id);
      // verify required parameter 'consequence' is not null or undefined
      assertParamExists('updateConsequence', 'consequence', consequence);
      const localVarPath = `/api/consequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(consequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConsequenceResourceApi - functional programming interface
 * @export
 */
export const ConsequenceResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConsequenceResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConsequence(
      consequence: Consequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConsequence(consequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConsequence(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConsequence(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllConsequences(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Consequence>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConsequences(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConsequence(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConsequence(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateConsequence(
      id: number,
      consequence: Consequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateConsequence(id, consequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConsequence(
      id: number,
      consequence: Consequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Consequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConsequence(id, consequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ConsequenceResourceApi - factory interface
 * @export
 */
export const ConsequenceResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ConsequenceResourceApiFp(configuration);
  return {
    /**
     *
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConsequence(consequence: Consequence, options?: any): AxiosPromise<Consequence> {
      return localVarFp.createConsequence(consequence, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConsequence(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteConsequence(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllConsequences(options?: any): AxiosPromise<Array<Consequence>> {
      return localVarFp.getAllConsequences(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConsequence(id: number, options?: any): AxiosPromise<Consequence> {
      return localVarFp.getConsequence(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateConsequence(id: number, consequence: Consequence, options?: any): AxiosPromise<Consequence> {
      return localVarFp.partialUpdateConsequence(id, consequence, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Consequence} consequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConsequence(id: number, consequence: Consequence, options?: any): AxiosPromise<Consequence> {
      return localVarFp.updateConsequence(id, consequence, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ConsequenceResourceApi - object-oriented interface
 * @export
 * @class ConsequenceResourceApi
 * @extends {BaseAPI}
 */
export class ConsequenceResourceApi extends BaseAPI {
  /**
   *
   * @param {Consequence} consequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public createConsequence(consequence: Consequence, options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .createConsequence(consequence, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public deleteConsequence(id: number, options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .deleteConsequence(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public getAllConsequences(options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .getAllConsequences(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public getConsequence(id: number, options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .getConsequence(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Consequence} consequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public partialUpdateConsequence(id: number, consequence: Consequence, options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .partialUpdateConsequence(id, consequence, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Consequence} consequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsequenceResourceApi
   */
  public updateConsequence(id: number, consequence: Consequence, options?: AxiosRequestConfig) {
    return ConsequenceResourceApiFp(this.configuration)
      .updateConsequence(id, consequence, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DeviceUsageIndicationResourceApi - axios parameter creator
 * @export
 */
export const DeviceUsageIndicationResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {DeviceUsageIndicationDTO} deviceUsageIndicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeviceUsageIndication: async (
      deviceUsageIndicationDTO: DeviceUsageIndicationDTO,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceUsageIndicationDTO' is not null or undefined
      assertParamExists('createDeviceUsageIndication', 'deviceUsageIndicationDTO', deviceUsageIndicationDTO);
      const localVarPath = `/api/device-usage-indications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(deviceUsageIndicationDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceUsageIndication: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDeviceUsageIndication', 'id', id);
      const localVarPath = `/api/device-usage-indications/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDeviceUsageIndications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/device-usage-indications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceUsageIndication: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDeviceUsageIndication', 'id', id);
      const localVarPath = `/api/device-usage-indications/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceUsageIndicationByFdaSubmission: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDeviceUsageIndicationByFdaSubmission', 'id', id);
      const localVarPath = `/api/device-usage-indications/fda-submission/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDeviceUsageIndication: async (
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateDeviceUsageIndication', 'id', id);
      // verify required parameter 'deviceUsageIndication' is not null or undefined
      assertParamExists('partialUpdateDeviceUsageIndication', 'deviceUsageIndication', deviceUsageIndication);
      const localVarPath = `/api/device-usage-indications/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(deviceUsageIndication, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeviceUsageIndication: async (
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateDeviceUsageIndication', 'id', id);
      // verify required parameter 'deviceUsageIndication' is not null or undefined
      assertParamExists('updateDeviceUsageIndication', 'deviceUsageIndication', deviceUsageIndication);
      const localVarPath = `/api/device-usage-indications/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(deviceUsageIndication, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DeviceUsageIndicationResourceApi - functional programming interface
 * @export
 */
export const DeviceUsageIndicationResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DeviceUsageIndicationResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {DeviceUsageIndicationDTO} deviceUsageIndicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDeviceUsageIndication(
      deviceUsageIndicationDTO: DeviceUsageIndicationDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUsageIndication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceUsageIndication(deviceUsageIndicationDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDeviceUsageIndication(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceUsageIndication(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllDeviceUsageIndications(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceUsageIndication>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeviceUsageIndications(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDeviceUsageIndication(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUsageIndication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceUsageIndication(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDeviceUsageIndicationByFdaSubmission(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceUsageIndication>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceUsageIndicationByFdaSubmission(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateDeviceUsageIndication(
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUsageIndication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateDeviceUsageIndication(id, deviceUsageIndication, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDeviceUsageIndication(
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceUsageIndication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceUsageIndication(id, deviceUsageIndication, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DeviceUsageIndicationResourceApi - factory interface
 * @export
 */
export const DeviceUsageIndicationResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DeviceUsageIndicationResourceApiFp(configuration);
  return {
    /**
     *
     * @param {DeviceUsageIndicationDTO} deviceUsageIndicationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDeviceUsageIndication(deviceUsageIndicationDTO: DeviceUsageIndicationDTO, options?: any): AxiosPromise<DeviceUsageIndication> {
      return localVarFp.createDeviceUsageIndication(deviceUsageIndicationDTO, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDeviceUsageIndication(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDeviceUsageIndication(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDeviceUsageIndications(options?: any): AxiosPromise<Array<DeviceUsageIndication>> {
      return localVarFp.getAllDeviceUsageIndications(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceUsageIndication(id: number, options?: any): AxiosPromise<DeviceUsageIndication> {
      return localVarFp.getDeviceUsageIndication(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeviceUsageIndicationByFdaSubmission(id: number, options?: any): AxiosPromise<Array<DeviceUsageIndication>> {
      return localVarFp.getDeviceUsageIndicationByFdaSubmission(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDeviceUsageIndication(
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options?: any
    ): AxiosPromise<DeviceUsageIndication> {
      return localVarFp.partialUpdateDeviceUsageIndication(id, deviceUsageIndication, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DeviceUsageIndication} deviceUsageIndication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDeviceUsageIndication(
      id: number,
      deviceUsageIndication: DeviceUsageIndication,
      options?: any
    ): AxiosPromise<DeviceUsageIndication> {
      return localVarFp.updateDeviceUsageIndication(id, deviceUsageIndication, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DeviceUsageIndicationResourceApi - object-oriented interface
 * @export
 * @class DeviceUsageIndicationResourceApi
 * @extends {BaseAPI}
 */
export class DeviceUsageIndicationResourceApi extends BaseAPI {
  /**
   *
   * @param {DeviceUsageIndicationDTO} deviceUsageIndicationDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public createDeviceUsageIndication(deviceUsageIndicationDTO: DeviceUsageIndicationDTO, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .createDeviceUsageIndication(deviceUsageIndicationDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public deleteDeviceUsageIndication(id: number, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .deleteDeviceUsageIndication(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public getAllDeviceUsageIndications(options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .getAllDeviceUsageIndications(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public getDeviceUsageIndication(id: number, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .getDeviceUsageIndication(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public getDeviceUsageIndicationByFdaSubmission(id: number, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .getDeviceUsageIndicationByFdaSubmission(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DeviceUsageIndication} deviceUsageIndication
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public partialUpdateDeviceUsageIndication(id: number, deviceUsageIndication: DeviceUsageIndication, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .partialUpdateDeviceUsageIndication(id, deviceUsageIndication, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DeviceUsageIndication} deviceUsageIndication
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeviceUsageIndicationResourceApi
   */
  public updateDeviceUsageIndication(id: number, deviceUsageIndication: DeviceUsageIndication, options?: AxiosRequestConfig) {
    return DeviceUsageIndicationResourceApiFp(this.configuration)
      .updateDeviceUsageIndication(id, deviceUsageIndication, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DrugBrandResourceApi - axios parameter creator
 * @export
 */
export const DrugBrandResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrugBrand: async (drugBrand: DrugBrand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'drugBrand' is not null or undefined
      assertParamExists('createDrugBrand', 'drugBrand', drugBrand);
      const localVarPath = `/api/drug-brands`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugBrand, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrugBrand: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDrugBrand', 'id', id);
      const localVarPath = `/api/drug-brands/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugBrands: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/drug-brands`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrugBrand: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDrugBrand', 'id', id);
      const localVarPath = `/api/drug-brands/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrugBrand: async (id: number, drugBrand: DrugBrand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateDrugBrand', 'id', id);
      // verify required parameter 'drugBrand' is not null or undefined
      assertParamExists('partialUpdateDrugBrand', 'drugBrand', drugBrand);
      const localVarPath = `/api/drug-brands/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugBrand, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrugBrand: async (id: number, drugBrand: DrugBrand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateDrugBrand', 'id', id);
      // verify required parameter 'drugBrand' is not null or undefined
      assertParamExists('updateDrugBrand', 'drugBrand', drugBrand);
      const localVarPath = `/api/drug-brands/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugBrand, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugBrandResourceApi - functional programming interface
 * @export
 */
export const DrugBrandResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugBrandResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDrugBrand(
      drugBrand: DrugBrand,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugBrand>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDrugBrand(drugBrand, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDrugBrand(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrugBrand(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllDrugBrands(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DrugBrand>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDrugBrands(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDrugBrand(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugBrand>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDrugBrand(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateDrugBrand(
      id: number,
      drugBrand: DrugBrand,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugBrand>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateDrugBrand(id, drugBrand, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDrugBrand(
      id: number,
      drugBrand: DrugBrand,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugBrand>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrugBrand(id, drugBrand, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DrugBrandResourceApi - factory interface
 * @export
 */
export const DrugBrandResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugBrandResourceApiFp(configuration);
  return {
    /**
     *
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrugBrand(drugBrand: DrugBrand, options?: any): AxiosPromise<DrugBrand> {
      return localVarFp.createDrugBrand(drugBrand, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrugBrand(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDrugBrand(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugBrands(options?: any): AxiosPromise<Array<DrugBrand>> {
      return localVarFp.getAllDrugBrands(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrugBrand(id: number, options?: any): AxiosPromise<DrugBrand> {
      return localVarFp.getDrugBrand(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrugBrand(id: number, drugBrand: DrugBrand, options?: any): AxiosPromise<DrugBrand> {
      return localVarFp.partialUpdateDrugBrand(id, drugBrand, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DrugBrand} drugBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrugBrand(id: number, drugBrand: DrugBrand, options?: any): AxiosPromise<DrugBrand> {
      return localVarFp.updateDrugBrand(id, drugBrand, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugBrandResourceApi - object-oriented interface
 * @export
 * @class DrugBrandResourceApi
 * @extends {BaseAPI}
 */
export class DrugBrandResourceApi extends BaseAPI {
  /**
   *
   * @param {DrugBrand} drugBrand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public createDrugBrand(drugBrand: DrugBrand, options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .createDrugBrand(drugBrand, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public deleteDrugBrand(id: number, options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .deleteDrugBrand(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public getAllDrugBrands(options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .getAllDrugBrands(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public getDrugBrand(id: number, options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .getDrugBrand(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DrugBrand} drugBrand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public partialUpdateDrugBrand(id: number, drugBrand: DrugBrand, options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .partialUpdateDrugBrand(id, drugBrand, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DrugBrand} drugBrand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugBrandResourceApi
   */
  public updateDrugBrand(id: number, drugBrand: DrugBrand, options?: AxiosRequestConfig) {
    return DrugBrandResourceApiFp(this.configuration)
      .updateDrugBrand(id, drugBrand, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DrugControllerApi - axios parameter creator
 * @export
 */
export const DrugControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugByCode: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists('findDrugByCode', 'code', code);
      const localVarPath = `/api/drugs/search-by-code/{code}`.replace(`{${'code'}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugs: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('findDrugs', 'query', query);
      const localVarPath = `/api/drugs/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugControllerApi - functional programming interface
 * @export
 */
export const DrugControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDrugByCode(
      code: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findDrugByCode(code, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDrugs(
      query: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findDrugs(query, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DrugControllerApi - factory interface
 * @export
 */
export const DrugControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugControllerApiFp(configuration);
  return {
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugByCode(code: string, options?: any): AxiosPromise<Drug> {
      return localVarFp.findDrugByCode(code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugs(query: string, options?: any): AxiosPromise<Array<Drug>> {
      return localVarFp.findDrugs(query, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugControllerApi - object-oriented interface
 * @export
 * @class DrugControllerApi
 * @extends {BaseAPI}
 */
export class DrugControllerApi extends BaseAPI {
  /**
   *
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugControllerApi
   */
  public findDrugByCode(code: string, options?: AxiosRequestConfig) {
    return DrugControllerApiFp(this.configuration)
      .findDrugByCode(code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugControllerApi
   */
  public findDrugs(query: string, options?: AxiosRequestConfig) {
    return DrugControllerApiFp(this.configuration)
      .findDrugs(query, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DrugResourceApi - axios parameter creator
 * @export
 */
export const DrugResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countDrugs: async (criteria: DrugCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countDrugs', 'criteria', criteria);
      const localVarPath = `/api/drugs/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrug: async (drug: Drug, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'drug' is not null or undefined
      assertParamExists('createDrug', 'drug', drug);
      const localVarPath = `/api/drugs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drug, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrug: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDrug', 'id', id);
      const localVarPath = `/api/drugs/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugs: async (criteria: DrugCriteria, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllDrugs', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllDrugs', 'pageable', pageable);
      const localVarPath = `/api/drugs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrug: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDrug', 'id', id);
      const localVarPath = `/api/drugs/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrug: async (id: number, drug: Drug, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateDrug', 'id', id);
      // verify required parameter 'drug' is not null or undefined
      assertParamExists('partialUpdateDrug', 'drug', drug);
      const localVarPath = `/api/drugs/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drug, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugs: async (query: string, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchDrugs', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchDrugs', 'pageable', pageable);
      const localVarPath = `/api/_search/drugs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrug: async (id: number, drug: Drug, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateDrug', 'id', id);
      // verify required parameter 'drug' is not null or undefined
      assertParamExists('updateDrug', 'drug', drug);
      const localVarPath = `/api/drugs/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drug, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugResourceApi - functional programming interface
 * @export
 */
export const DrugResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countDrugs(
      criteria: DrugCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countDrugs(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDrug(drug: Drug, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDrug(drug, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDrug(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrug(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllDrugs(
      criteria: DrugCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDrugs(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDrug(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDrug(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateDrug(
      id: number,
      drug: Drug,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateDrug(id, drug, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDrugs(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchDrugs(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDrug(
      id: number,
      drug: Drug,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrug(id, drug, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DrugResourceApi - factory interface
 * @export
 */
export const DrugResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugResourceApiFp(configuration);
  return {
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countDrugs(criteria: DrugCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countDrugs(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrug(drug: Drug, options?: any): AxiosPromise<Drug> {
      return localVarFp.createDrug(drug, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrug(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDrug(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {DrugCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugs(criteria: DrugCriteria, pageable: Pageable, options?: any): AxiosPromise<Array<Drug>> {
      return localVarFp.getAllDrugs(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrug(id: number, options?: any): AxiosPromise<Drug> {
      return localVarFp.getDrug(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrug(id: number, drug: Drug, options?: any): AxiosPromise<Drug> {
      return localVarFp.partialUpdateDrug(id, drug, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugs(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<Drug>> {
      return localVarFp.searchDrugs(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Drug} drug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrug(id: number, drug: Drug, options?: any): AxiosPromise<Drug> {
      return localVarFp.updateDrug(id, drug, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugResourceApi - object-oriented interface
 * @export
 * @class DrugResourceApi
 * @extends {BaseAPI}
 */
export class DrugResourceApi extends BaseAPI {
  /**
   *
   * @param {DrugCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public countDrugs(criteria: DrugCriteria, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .countDrugs(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Drug} drug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public createDrug(drug: Drug, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .createDrug(drug, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public deleteDrug(id: number, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .deleteDrug(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DrugCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public getAllDrugs(criteria: DrugCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .getAllDrugs(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public getDrug(id: number, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .getDrug(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Drug} drug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public partialUpdateDrug(id: number, drug: Drug, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .partialUpdateDrug(id, drug, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public searchDrugs(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .searchDrugs(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Drug} drug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugResourceApi
   */
  public updateDrug(id: number, drug: Drug, options?: AxiosRequestConfig) {
    return DrugResourceApiFp(this.configuration)
      .updateDrug(id, drug, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DrugSynonymResourceApi - axios parameter creator
 * @export
 */
export const DrugSynonymResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrugSynonym: async (drugSynonym: DrugSynonym, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'drugSynonym' is not null or undefined
      assertParamExists('createDrugSynonym', 'drugSynonym', drugSynonym);
      const localVarPath = `/api/drug-synonyms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugSynonym, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrugSynonym: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteDrugSynonym', 'id', id);
      const localVarPath = `/api/drug-synonyms/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugSynonyms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/drug-synonyms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrugSynonym: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDrugSynonym', 'id', id);
      const localVarPath = `/api/drug-synonyms/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrugSynonym: async (id: number, drugSynonym: DrugSynonym, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateDrugSynonym', 'id', id);
      // verify required parameter 'drugSynonym' is not null or undefined
      assertParamExists('partialUpdateDrugSynonym', 'drugSynonym', drugSynonym);
      const localVarPath = `/api/drug-synonyms/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugSynonym, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrugSynonym: async (id: number, drugSynonym: DrugSynonym, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateDrugSynonym', 'id', id);
      // verify required parameter 'drugSynonym' is not null or undefined
      assertParamExists('updateDrugSynonym', 'drugSynonym', drugSynonym);
      const localVarPath = `/api/drug-synonyms/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(drugSynonym, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugSynonymResourceApi - functional programming interface
 * @export
 */
export const DrugSynonymResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugSynonymResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDrugSynonym(
      drugSynonym: DrugSynonym,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugSynonym>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDrugSynonym(drugSynonym, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDrugSynonym(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDrugSynonym(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllDrugSynonyms(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DrugSynonym>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDrugSynonyms(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDrugSynonym(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugSynonym>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDrugSynonym(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateDrugSynonym(
      id: number,
      drugSynonym: DrugSynonym,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugSynonym>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateDrugSynonym(id, drugSynonym, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDrugSynonym(
      id: number,
      drugSynonym: DrugSynonym,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrugSynonym>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDrugSynonym(id, drugSynonym, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DrugSynonymResourceApi - factory interface
 * @export
 */
export const DrugSynonymResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugSynonymResourceApiFp(configuration);
  return {
    /**
     *
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDrugSynonym(drugSynonym: DrugSynonym, options?: any): AxiosPromise<DrugSynonym> {
      return localVarFp.createDrugSynonym(drugSynonym, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDrugSynonym(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDrugSynonym(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllDrugSynonyms(options?: any): AxiosPromise<Array<DrugSynonym>> {
      return localVarFp.getAllDrugSynonyms(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDrugSynonym(id: number, options?: any): AxiosPromise<DrugSynonym> {
      return localVarFp.getDrugSynonym(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateDrugSynonym(id: number, drugSynonym: DrugSynonym, options?: any): AxiosPromise<DrugSynonym> {
      return localVarFp.partialUpdateDrugSynonym(id, drugSynonym, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {DrugSynonym} drugSynonym
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDrugSynonym(id: number, drugSynonym: DrugSynonym, options?: any): AxiosPromise<DrugSynonym> {
      return localVarFp.updateDrugSynonym(id, drugSynonym, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugSynonymResourceApi - object-oriented interface
 * @export
 * @class DrugSynonymResourceApi
 * @extends {BaseAPI}
 */
export class DrugSynonymResourceApi extends BaseAPI {
  /**
   *
   * @param {DrugSynonym} drugSynonym
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public createDrugSynonym(drugSynonym: DrugSynonym, options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .createDrugSynonym(drugSynonym, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public deleteDrugSynonym(id: number, options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .deleteDrugSynonym(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public getAllDrugSynonyms(options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .getAllDrugSynonyms(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public getDrugSynonym(id: number, options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .getDrugSynonym(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DrugSynonym} drugSynonym
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public partialUpdateDrugSynonym(id: number, drugSynonym: DrugSynonym, options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .partialUpdateDrugSynonym(id, drugSynonym, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {DrugSynonym} drugSynonym
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugSynonymResourceApi
   */
  public updateDrugSynonym(id: number, drugSynonym: DrugSynonym, options?: AxiosRequestConfig) {
    return DrugSynonymResourceApiFp(this.configuration)
      .updateDrugSynonym(id, drugSynonym, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EnsemblGeneControllerApi - axios parameter creator
 * @export
 */
export const EnsemblGeneControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {string} ensemblGeneId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEnsemblGene: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('addEnsemblGene', 'referenceGenome', referenceGenome);
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('addEnsemblGene', 'entrezGeneId', entrezGeneId);
      // verify required parameter 'ensemblGeneId' is not null or undefined
      assertParamExists('addEnsemblGene', 'ensemblGeneId', ensemblGeneId);
      // verify required parameter 'isCanonical' is not null or undefined
      assertParamExists('addEnsemblGene', 'isCanonical', isCanonical);
      const localVarPath = `/api/add-ensembl-gene`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (ensemblGeneId !== undefined) {
        localVarQueryParameter['ensemblGeneId'] = ensemblGeneId;
      }

      if (isCanonical !== undefined) {
        localVarQueryParameter['isCanonical'] = isCanonical;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnsemblGeneControllerApi - functional programming interface
 * @export
 */
export const EnsemblGeneControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnsemblGeneControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {string} ensemblGeneId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addEnsemblGene(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addEnsemblGene(
        referenceGenome,
        entrezGeneId,
        ensemblGeneId,
        isCanonical,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EnsemblGeneControllerApi - factory interface
 * @export
 */
export const EnsemblGeneControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EnsemblGeneControllerApiFp(configuration);
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {string} ensemblGeneId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEnsemblGene(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options?: any
    ): AxiosPromise<EnsemblGene> {
      return localVarFp
        .addEnsemblGene(referenceGenome, entrezGeneId, ensemblGeneId, isCanonical, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * EnsemblGeneControllerApi - object-oriented interface
 * @export
 * @class EnsemblGeneControllerApi
 * @extends {BaseAPI}
 */
export class EnsemblGeneControllerApi extends BaseAPI {
  /**
   *
   * @param {'GRCh37' | 'GRCh38'} referenceGenome
   * @param {number} entrezGeneId
   * @param {string} ensemblGeneId
   * @param {boolean} isCanonical
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneControllerApi
   */
  public addEnsemblGene(
    referenceGenome: 'GRCh37' | 'GRCh38',
    entrezGeneId: number,
    ensemblGeneId: string,
    isCanonical: boolean,
    options?: AxiosRequestConfig
  ) {
    return EnsemblGeneControllerApiFp(this.configuration)
      .addEnsemblGene(referenceGenome, entrezGeneId, ensemblGeneId, isCanonical, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EnsemblGeneResourceApi - axios parameter creator
 * @export
 */
export const EnsemblGeneResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnsemblGene: async (ensemblGene: EnsemblGene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'ensemblGene' is not null or undefined
      assertParamExists('createEnsemblGene', 'ensemblGene', ensemblGene);
      const localVarPath = `/api/ensembl-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(ensemblGene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnsemblGene: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteEnsemblGene', 'id', id);
      const localVarPath = `/api/ensembl-genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEnsemblGenes: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllEnsemblGenes', 'pageable', pageable);
      const localVarPath = `/api/ensembl-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnsemblGene: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getEnsemblGene', 'id', id);
      const localVarPath = `/api/ensembl-genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateEnsemblGene: async (id: number, ensemblGene: EnsemblGene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateEnsemblGene', 'id', id);
      // verify required parameter 'ensemblGene' is not null or undefined
      assertParamExists('partialUpdateEnsemblGene', 'ensemblGene', ensemblGene);
      const localVarPath = `/api/ensembl-genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(ensemblGene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnsemblGene: async (id: number, ensemblGene: EnsemblGene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateEnsemblGene', 'id', id);
      // verify required parameter 'ensemblGene' is not null or undefined
      assertParamExists('updateEnsemblGene', 'ensemblGene', ensemblGene);
      const localVarPath = `/api/ensembl-genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(ensemblGene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnsemblGeneResourceApi - functional programming interface
 * @export
 */
export const EnsemblGeneResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnsemblGeneResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnsemblGene(
      ensemblGene: EnsemblGene,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnsemblGene(ensemblGene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnsemblGene(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnsemblGene(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllEnsemblGenes(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnsemblGene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEnsemblGenes(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnsemblGene(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnsemblGene(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateEnsemblGene(
      id: number,
      ensemblGene: EnsemblGene,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateEnsemblGene(id, ensemblGene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEnsemblGene(
      id: number,
      ensemblGene: EnsemblGene,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnsemblGene(id, ensemblGene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EnsemblGeneResourceApi - factory interface
 * @export
 */
export const EnsemblGeneResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EnsemblGeneResourceApiFp(configuration);
  return {
    /**
     *
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnsemblGene(ensemblGene: EnsemblGene, options?: any): AxiosPromise<EnsemblGene> {
      return localVarFp.createEnsemblGene(ensemblGene, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnsemblGene(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteEnsemblGene(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllEnsemblGenes(pageable: Pageable, options?: any): AxiosPromise<Array<EnsemblGene>> {
      return localVarFp.getAllEnsemblGenes(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnsemblGene(id: number, options?: any): AxiosPromise<EnsemblGene> {
      return localVarFp.getEnsemblGene(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateEnsemblGene(id: number, ensemblGene: EnsemblGene, options?: any): AxiosPromise<EnsemblGene> {
      return localVarFp.partialUpdateEnsemblGene(id, ensemblGene, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {EnsemblGene} ensemblGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnsemblGene(id: number, ensemblGene: EnsemblGene, options?: any): AxiosPromise<EnsemblGene> {
      return localVarFp.updateEnsemblGene(id, ensemblGene, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * EnsemblGeneResourceApi - object-oriented interface
 * @export
 * @class EnsemblGeneResourceApi
 * @extends {BaseAPI}
 */
export class EnsemblGeneResourceApi extends BaseAPI {
  /**
   *
   * @param {EnsemblGene} ensemblGene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public createEnsemblGene(ensemblGene: EnsemblGene, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .createEnsemblGene(ensemblGene, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public deleteEnsemblGene(id: number, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .deleteEnsemblGene(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public getAllEnsemblGenes(pageable: Pageable, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .getAllEnsemblGenes(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public getEnsemblGene(id: number, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .getEnsemblGene(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {EnsemblGene} ensemblGene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public partialUpdateEnsemblGene(id: number, ensemblGene: EnsemblGene, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .partialUpdateEnsemblGene(id, ensemblGene, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {EnsemblGene} ensemblGene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneResourceApi
   */
  public updateEnsemblGene(id: number, ensemblGene: EnsemblGene, options?: AxiosRequestConfig) {
    return EnsemblGeneResourceApiFp(this.configuration)
      .updateEnsemblGene(id, ensemblGene, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FdaSubmissionResourceApi - axios parameter creator
 * @export
 */
export const FdaSubmissionResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countFdaSubmissions: async (criteria: FdaSubmissionCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countFdaSubmissions', 'criteria', criteria);
      const localVarPath = `/api/fda-submissions/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFdaSubmission: async (fdaSubmission: FdaSubmission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fdaSubmission' is not null or undefined
      assertParamExists('createFdaSubmission', 'fdaSubmission', fdaSubmission);
      const localVarPath = `/api/fda-submissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmission, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFdaSubmission: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFdaSubmission', 'id', id);
      const localVarPath = `/api/fda-submissions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFdaSubmissions: async (
      criteria: FdaSubmissionCriteria,
      pageable: Pageable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllFdaSubmissions', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllFdaSubmissions', 'pageable', pageable);
      const localVarPath = `/api/fda-submissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmission: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFdaSubmission', 'id', id);
      const localVarPath = `/api/fda-submissions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} number
     * @param {string} [supplementNumber]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmissionByNumber: async (number: string, supplementNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'number' is not null or undefined
      assertParamExists('getFdaSubmissionByNumber', 'number', number);
      const localVarPath = `/api/fda-submissions/lookup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (number !== undefined) {
        localVarQueryParameter['number'] = number;
      }

      if (supplementNumber !== undefined) {
        localVarQueryParameter['supplementNumber'] = supplementNumber;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateFdaSubmission: async (
      id: number,
      fdaSubmission: FdaSubmission,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateFdaSubmission', 'id', id);
      // verify required parameter 'fdaSubmission' is not null or undefined
      assertParamExists('partialUpdateFdaSubmission', 'fdaSubmission', fdaSubmission);
      const localVarPath = `/api/fda-submissions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmission, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFdaSubmissions: async (query: string, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchFdaSubmissions', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchFdaSubmissions', 'pageable', pageable);
      const localVarPath = `/api/_search/fda-submissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFdaSubmission: async (id: number, fdaSubmission: FdaSubmission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFdaSubmission', 'id', id);
      // verify required parameter 'fdaSubmission' is not null or undefined
      assertParamExists('updateFdaSubmission', 'fdaSubmission', fdaSubmission);
      const localVarPath = `/api/fda-submissions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmission, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FdaSubmissionResourceApi - functional programming interface
 * @export
 */
export const FdaSubmissionResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FdaSubmissionResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countFdaSubmissions(
      criteria: FdaSubmissionCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countFdaSubmissions(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFdaSubmission(
      fdaSubmission: FdaSubmission,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFdaSubmission(fdaSubmission, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFdaSubmission(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFdaSubmission(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllFdaSubmissions(
      criteria: FdaSubmissionCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FdaSubmission>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFdaSubmissions(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFdaSubmission(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFdaSubmission(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} number
     * @param {string} [supplementNumber]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFdaSubmissionByNumber(
      number: string,
      supplementNumber?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFdaSubmissionByNumber(number, supplementNumber, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateFdaSubmission(
      id: number,
      fdaSubmission: FdaSubmission,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateFdaSubmission(id, fdaSubmission, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchFdaSubmissions(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FdaSubmission>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchFdaSubmissions(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFdaSubmission(
      id: number,
      fdaSubmission: FdaSubmission,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFdaSubmission(id, fdaSubmission, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FdaSubmissionResourceApi - factory interface
 * @export
 */
export const FdaSubmissionResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FdaSubmissionResourceApiFp(configuration);
  return {
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countFdaSubmissions(criteria: FdaSubmissionCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countFdaSubmissions(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFdaSubmission(fdaSubmission: FdaSubmission, options?: any): AxiosPromise<FdaSubmission> {
      return localVarFp.createFdaSubmission(fdaSubmission, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFdaSubmission(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteFdaSubmission(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {FdaSubmissionCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFdaSubmissions(criteria: FdaSubmissionCriteria, pageable: Pageable, options?: any): AxiosPromise<Array<FdaSubmission>> {
      return localVarFp.getAllFdaSubmissions(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmission(id: number, options?: any): AxiosPromise<FdaSubmission> {
      return localVarFp.getFdaSubmission(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} number
     * @param {string} [supplementNumber]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmissionByNumber(number: string, supplementNumber?: string, options?: any): AxiosPromise<FdaSubmission> {
      return localVarFp.getFdaSubmissionByNumber(number, supplementNumber, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateFdaSubmission(id: number, fdaSubmission: FdaSubmission, options?: any): AxiosPromise<FdaSubmission> {
      return localVarFp.partialUpdateFdaSubmission(id, fdaSubmission, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchFdaSubmissions(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<FdaSubmission>> {
      return localVarFp.searchFdaSubmissions(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmission} fdaSubmission
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFdaSubmission(id: number, fdaSubmission: FdaSubmission, options?: any): AxiosPromise<FdaSubmission> {
      return localVarFp.updateFdaSubmission(id, fdaSubmission, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * FdaSubmissionResourceApi - object-oriented interface
 * @export
 * @class FdaSubmissionResourceApi
 * @extends {BaseAPI}
 */
export class FdaSubmissionResourceApi extends BaseAPI {
  /**
   *
   * @param {FdaSubmissionCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public countFdaSubmissions(criteria: FdaSubmissionCriteria, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .countFdaSubmissions(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FdaSubmission} fdaSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public createFdaSubmission(fdaSubmission: FdaSubmission, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .createFdaSubmission(fdaSubmission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public deleteFdaSubmission(id: number, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .deleteFdaSubmission(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FdaSubmissionCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public getAllFdaSubmissions(criteria: FdaSubmissionCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .getAllFdaSubmissions(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public getFdaSubmission(id: number, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .getFdaSubmission(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} number
   * @param {string} [supplementNumber]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public getFdaSubmissionByNumber(number: string, supplementNumber?: string, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .getFdaSubmissionByNumber(number, supplementNumber, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {FdaSubmission} fdaSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public partialUpdateFdaSubmission(id: number, fdaSubmission: FdaSubmission, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .partialUpdateFdaSubmission(id, fdaSubmission, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public searchFdaSubmissions(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .searchFdaSubmissions(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {FdaSubmission} fdaSubmission
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionResourceApi
   */
  public updateFdaSubmission(id: number, fdaSubmission: FdaSubmission, options?: AxiosRequestConfig) {
    return FdaSubmissionResourceApiFp(this.configuration)
      .updateFdaSubmission(id, fdaSubmission, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FdaSubmissionTypeResourceApi - axios parameter creator
 * @export
 */
export const FdaSubmissionTypeResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFdaSubmissionType: async (fdaSubmissionType: FdaSubmissionType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fdaSubmissionType' is not null or undefined
      assertParamExists('createFdaSubmissionType', 'fdaSubmissionType', fdaSubmissionType);
      const localVarPath = `/api/fda-submission-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmissionType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFdaSubmissionType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFdaSubmissionType', 'id', id);
      const localVarPath = `/api/fda-submission-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFdaSubmissionTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/fda-submission-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmissionType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFdaSubmissionType', 'id', id);
      const localVarPath = `/api/fda-submission-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateFdaSubmissionType: async (
      id: number,
      fdaSubmissionType: FdaSubmissionType,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateFdaSubmissionType', 'id', id);
      // verify required parameter 'fdaSubmissionType' is not null or undefined
      assertParamExists('partialUpdateFdaSubmissionType', 'fdaSubmissionType', fdaSubmissionType);
      const localVarPath = `/api/fda-submission-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmissionType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFdaSubmissionType: async (
      id: number,
      fdaSubmissionType: FdaSubmissionType,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFdaSubmissionType', 'id', id);
      // verify required parameter 'fdaSubmissionType' is not null or undefined
      assertParamExists('updateFdaSubmissionType', 'fdaSubmissionType', fdaSubmissionType);
      const localVarPath = `/api/fda-submission-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(fdaSubmissionType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FdaSubmissionTypeResourceApi - functional programming interface
 * @export
 */
export const FdaSubmissionTypeResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FdaSubmissionTypeResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFdaSubmissionType(
      fdaSubmissionType: FdaSubmissionType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmissionType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFdaSubmissionType(fdaSubmissionType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFdaSubmissionType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFdaSubmissionType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllFdaSubmissionTypes(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FdaSubmissionType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFdaSubmissionTypes(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFdaSubmissionType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmissionType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFdaSubmissionType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateFdaSubmissionType(
      id: number,
      fdaSubmissionType: FdaSubmissionType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmissionType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateFdaSubmissionType(id, fdaSubmissionType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFdaSubmissionType(
      id: number,
      fdaSubmissionType: FdaSubmissionType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FdaSubmissionType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFdaSubmissionType(id, fdaSubmissionType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FdaSubmissionTypeResourceApi - factory interface
 * @export
 */
export const FdaSubmissionTypeResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FdaSubmissionTypeResourceApiFp(configuration);
  return {
    /**
     *
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFdaSubmissionType(fdaSubmissionType: FdaSubmissionType, options?: any): AxiosPromise<FdaSubmissionType> {
      return localVarFp.createFdaSubmissionType(fdaSubmissionType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFdaSubmissionType(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteFdaSubmissionType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFdaSubmissionTypes(options?: any): AxiosPromise<Array<FdaSubmissionType>> {
      return localVarFp.getAllFdaSubmissionTypes(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFdaSubmissionType(id: number, options?: any): AxiosPromise<FdaSubmissionType> {
      return localVarFp.getFdaSubmissionType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateFdaSubmissionType(id: number, fdaSubmissionType: FdaSubmissionType, options?: any): AxiosPromise<FdaSubmissionType> {
      return localVarFp.partialUpdateFdaSubmissionType(id, fdaSubmissionType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {FdaSubmissionType} fdaSubmissionType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFdaSubmissionType(id: number, fdaSubmissionType: FdaSubmissionType, options?: any): AxiosPromise<FdaSubmissionType> {
      return localVarFp.updateFdaSubmissionType(id, fdaSubmissionType, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * FdaSubmissionTypeResourceApi - object-oriented interface
 * @export
 * @class FdaSubmissionTypeResourceApi
 * @extends {BaseAPI}
 */
export class FdaSubmissionTypeResourceApi extends BaseAPI {
  /**
   *
   * @param {FdaSubmissionType} fdaSubmissionType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public createFdaSubmissionType(fdaSubmissionType: FdaSubmissionType, options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .createFdaSubmissionType(fdaSubmissionType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public deleteFdaSubmissionType(id: number, options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .deleteFdaSubmissionType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public getAllFdaSubmissionTypes(options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .getAllFdaSubmissionTypes(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public getFdaSubmissionType(id: number, options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .getFdaSubmissionType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {FdaSubmissionType} fdaSubmissionType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public partialUpdateFdaSubmissionType(id: number, fdaSubmissionType: FdaSubmissionType, options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .partialUpdateFdaSubmissionType(id, fdaSubmissionType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {FdaSubmissionType} fdaSubmissionType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FdaSubmissionTypeResourceApi
   */
  public updateFdaSubmissionType(id: number, fdaSubmissionType: FdaSubmissionType, options?: AxiosRequestConfig) {
    return FdaSubmissionTypeResourceApiFp(this.configuration)
      .updateFdaSubmissionType(id, fdaSubmissionType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * GeneAliasResourceApi - axios parameter creator
 * @export
 */
export const GeneAliasResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeneAlias: async (geneAlias: GeneAlias, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'geneAlias' is not null or undefined
      assertParamExists('createGeneAlias', 'geneAlias', geneAlias);
      const localVarPath = `/api/gene-aliases`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(geneAlias, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGeneAlias: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteGeneAlias', 'id', id);
      const localVarPath = `/api/gene-aliases/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGeneAliases: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/gene-aliases`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeneAlias: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGeneAlias', 'id', id);
      const localVarPath = `/api/gene-aliases/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGeneAlias: async (id: number, geneAlias: GeneAlias, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateGeneAlias', 'id', id);
      // verify required parameter 'geneAlias' is not null or undefined
      assertParamExists('partialUpdateGeneAlias', 'geneAlias', geneAlias);
      const localVarPath = `/api/gene-aliases/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(geneAlias, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGeneAlias: async (id: number, geneAlias: GeneAlias, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateGeneAlias', 'id', id);
      // verify required parameter 'geneAlias' is not null or undefined
      assertParamExists('updateGeneAlias', 'geneAlias', geneAlias);
      const localVarPath = `/api/gene-aliases/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(geneAlias, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneAliasResourceApi - functional programming interface
 * @export
 */
export const GeneAliasResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneAliasResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGeneAlias(
      geneAlias: GeneAlias,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneAlias>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGeneAlias(geneAlias, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGeneAlias(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGeneAlias(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllGeneAliases(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneAlias>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGeneAliases(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeneAlias(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneAlias>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneAlias(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateGeneAlias(
      id: number,
      geneAlias: GeneAlias,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneAlias>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateGeneAlias(id, geneAlias, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGeneAlias(
      id: number,
      geneAlias: GeneAlias,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneAlias>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGeneAlias(id, geneAlias, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GeneAliasResourceApi - factory interface
 * @export
 */
export const GeneAliasResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GeneAliasResourceApiFp(configuration);
  return {
    /**
     *
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGeneAlias(geneAlias: GeneAlias, options?: any): AxiosPromise<GeneAlias> {
      return localVarFp.createGeneAlias(geneAlias, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGeneAlias(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGeneAlias(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGeneAliases(options?: any): AxiosPromise<Array<GeneAlias>> {
      return localVarFp.getAllGeneAliases(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeneAlias(id: number, options?: any): AxiosPromise<GeneAlias> {
      return localVarFp.getGeneAlias(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGeneAlias(id: number, geneAlias: GeneAlias, options?: any): AxiosPromise<GeneAlias> {
      return localVarFp.partialUpdateGeneAlias(id, geneAlias, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {GeneAlias} geneAlias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGeneAlias(id: number, geneAlias: GeneAlias, options?: any): AxiosPromise<GeneAlias> {
      return localVarFp.updateGeneAlias(id, geneAlias, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * GeneAliasResourceApi - object-oriented interface
 * @export
 * @class GeneAliasResourceApi
 * @extends {BaseAPI}
 */
export class GeneAliasResourceApi extends BaseAPI {
  /**
   *
   * @param {GeneAlias} geneAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public createGeneAlias(geneAlias: GeneAlias, options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .createGeneAlias(geneAlias, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public deleteGeneAlias(id: number, options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .deleteGeneAlias(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public getAllGeneAliases(options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .getAllGeneAliases(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public getGeneAlias(id: number, options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .getGeneAlias(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {GeneAlias} geneAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public partialUpdateGeneAlias(id: number, geneAlias: GeneAlias, options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .partialUpdateGeneAlias(id, geneAlias, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {GeneAlias} geneAlias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneAliasResourceApi
   */
  public updateGeneAlias(id: number, geneAlias: GeneAlias, options?: AxiosRequestConfig) {
    return GeneAliasResourceApiFp(this.configuration)
      .updateGeneAlias(id, geneAlias, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * GeneControllerApi - axios parameter creator
 * @export
 */
export const GeneControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGeneBySymbol: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      assertParamExists('findGeneBySymbol', 'symbol', symbol);
      const localVarPath = `/api/find-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGenesBySymbols: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('findGenesBySymbols', 'requestBody', requestBody);
      const localVarPath = `/api/find-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneControllerApi - functional programming interface
 * @export
 */
export const GeneControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGeneBySymbol(
      symbol: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGeneBySymbol(symbol, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGenesBySymbols(
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Gene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGenesBySymbols(requestBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GeneControllerApi - factory interface
 * @export
 */
export const GeneControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GeneControllerApiFp(configuration);
  return {
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGeneBySymbol(symbol: string, options?: any): AxiosPromise<Gene> {
      return localVarFp.findGeneBySymbol(symbol, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGenesBySymbols(requestBody: Array<string>, options?: any): AxiosPromise<Set<Gene>> {
      return localVarFp.findGenesBySymbols(requestBody, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * GeneControllerApi - object-oriented interface
 * @export
 * @class GeneControllerApi
 * @extends {BaseAPI}
 */
export class GeneControllerApi extends BaseAPI {
  /**
   *
   * @param {string} symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneControllerApi
   */
  public findGeneBySymbol(symbol: string, options?: AxiosRequestConfig) {
    return GeneControllerApiFp(this.configuration)
      .findGeneBySymbol(symbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneControllerApi
   */
  public findGenesBySymbols(requestBody: Array<string>, options?: AxiosRequestConfig) {
    return GeneControllerApiFp(this.configuration)
      .findGenesBySymbols(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * GeneResourceApi - axios parameter creator
 * @export
 */
export const GeneResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countGenes: async (criteria: GeneCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('countGenes', 'criteria', criteria);
      const localVarPath = `/api/genes/count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGene: async (gene: Gene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'gene' is not null or undefined
      assertParamExists('createGene', 'gene', gene);
      const localVarPath = `/api/genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGene: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteGene', 'id', id);
      const localVarPath = `/api/genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGenes: async (criteria: GeneCriteria, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'criteria' is not null or undefined
      assertParamExists('getAllGenes', 'criteria', criteria);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllGenes', 'pageable', pageable);
      const localVarPath = `/api/genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (criteria !== undefined) {
        localVarQueryParameter['criteria'] = criteria;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGene: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGene', 'id', id);
      const localVarPath = `/api/genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGene: async (id: number, gene: Gene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateGene', 'id', id);
      // verify required parameter 'gene' is not null or undefined
      assertParamExists('partialUpdateGene', 'gene', gene);
      const localVarPath = `/api/genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGenes: async (query: string, pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchGenes', 'query', query);
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('searchGenes', 'pageable', pageable);
      const localVarPath = `/api/_search/genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGene: async (id: number, gene: Gene, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateGene', 'id', id);
      // verify required parameter 'gene' is not null or undefined
      assertParamExists('updateGene', 'gene', gene);
      const localVarPath = `/api/genes/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gene, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneResourceApi - functional programming interface
 * @export
 */
export const GeneResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async countGenes(
      criteria: GeneCriteria,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.countGenes(criteria, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGene(gene: Gene, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGene(gene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGene(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGene(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllGenes(
      criteria: GeneCriteria,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGenes(criteria, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGene(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGene(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateGene(
      id: number,
      gene: Gene,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateGene(id, gene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchGenes(
      query: string,
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchGenes(query, pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGene(
      id: number,
      gene: Gene,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGene(id, gene, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GeneResourceApi - factory interface
 * @export
 */
export const GeneResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GeneResourceApiFp(configuration);
  return {
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    countGenes(criteria: GeneCriteria, options?: any): AxiosPromise<number> {
      return localVarFp.countGenes(criteria, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGene(gene: Gene, options?: any): AxiosPromise<Gene> {
      return localVarFp.createGene(gene, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGene(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGene(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {GeneCriteria} criteria
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGenes(criteria: GeneCriteria, pageable: Pageable, options?: any): AxiosPromise<Array<Gene>> {
      return localVarFp.getAllGenes(criteria, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGene(id: number, options?: any): AxiosPromise<Gene> {
      return localVarFp.getGene(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGene(id: number, gene: Gene, options?: any): AxiosPromise<Gene> {
      return localVarFp.partialUpdateGene(id, gene, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} query
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGenes(query: string, pageable: Pageable, options?: any): AxiosPromise<Array<Gene>> {
      return localVarFp.searchGenes(query, pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Gene} gene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGene(id: number, gene: Gene, options?: any): AxiosPromise<Gene> {
      return localVarFp.updateGene(id, gene, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * GeneResourceApi - object-oriented interface
 * @export
 * @class GeneResourceApi
 * @extends {BaseAPI}
 */
export class GeneResourceApi extends BaseAPI {
  /**
   *
   * @param {GeneCriteria} criteria
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public countGenes(criteria: GeneCriteria, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .countGenes(criteria, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Gene} gene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public createGene(gene: Gene, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .createGene(gene, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public deleteGene(id: number, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .deleteGene(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GeneCriteria} criteria
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public getAllGenes(criteria: GeneCriteria, pageable: Pageable, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .getAllGenes(criteria, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public getGene(id: number, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .getGene(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Gene} gene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public partialUpdateGene(id: number, gene: Gene, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .partialUpdateGene(id, gene, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} query
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public searchGenes(query: string, pageable: Pageable, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .searchGenes(query, pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Gene} gene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneResourceApi
   */
  public updateGene(id: number, gene: Gene, options?: AxiosRequestConfig) {
    return GeneResourceApiFp(this.configuration)
      .updateGene(id, gene, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * GenomeFragmentResourceApi - axios parameter creator
 * @export
 */
export const GenomeFragmentResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGenomeFragment: async (genomeFragment: GenomeFragment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'genomeFragment' is not null or undefined
      assertParamExists('createGenomeFragment', 'genomeFragment', genomeFragment);
      const localVarPath = `/api/genome-fragments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(genomeFragment, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGenomeFragment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteGenomeFragment', 'id', id);
      const localVarPath = `/api/genome-fragments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGenomeFragments: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllGenomeFragments', 'pageable', pageable);
      const localVarPath = `/api/genome-fragments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGenomeFragment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getGenomeFragment', 'id', id);
      const localVarPath = `/api/genome-fragments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGenomeFragment: async (
      id: number,
      genomeFragment: GenomeFragment,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateGenomeFragment', 'id', id);
      // verify required parameter 'genomeFragment' is not null or undefined
      assertParamExists('partialUpdateGenomeFragment', 'genomeFragment', genomeFragment);
      const localVarPath = `/api/genome-fragments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(genomeFragment, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGenomeFragment: async (id: number, genomeFragment: GenomeFragment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateGenomeFragment', 'id', id);
      // verify required parameter 'genomeFragment' is not null or undefined
      assertParamExists('updateGenomeFragment', 'genomeFragment', genomeFragment);
      const localVarPath = `/api/genome-fragments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(genomeFragment, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GenomeFragmentResourceApi - functional programming interface
 * @export
 */
export const GenomeFragmentResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GenomeFragmentResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGenomeFragment(
      genomeFragment: GenomeFragment,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenomeFragment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGenomeFragment(genomeFragment, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGenomeFragment(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGenomeFragment(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllGenomeFragments(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenomeFragment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGenomeFragments(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGenomeFragment(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenomeFragment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGenomeFragment(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateGenomeFragment(
      id: number,
      genomeFragment: GenomeFragment,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenomeFragment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateGenomeFragment(id, genomeFragment, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGenomeFragment(
      id: number,
      genomeFragment: GenomeFragment,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenomeFragment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGenomeFragment(id, genomeFragment, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GenomeFragmentResourceApi - factory interface
 * @export
 */
export const GenomeFragmentResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GenomeFragmentResourceApiFp(configuration);
  return {
    /**
     *
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGenomeFragment(genomeFragment: GenomeFragment, options?: any): AxiosPromise<GenomeFragment> {
      return localVarFp.createGenomeFragment(genomeFragment, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGenomeFragment(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGenomeFragment(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGenomeFragments(pageable: Pageable, options?: any): AxiosPromise<Array<GenomeFragment>> {
      return localVarFp.getAllGenomeFragments(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGenomeFragment(id: number, options?: any): AxiosPromise<GenomeFragment> {
      return localVarFp.getGenomeFragment(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateGenomeFragment(id: number, genomeFragment: GenomeFragment, options?: any): AxiosPromise<GenomeFragment> {
      return localVarFp.partialUpdateGenomeFragment(id, genomeFragment, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {GenomeFragment} genomeFragment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGenomeFragment(id: number, genomeFragment: GenomeFragment, options?: any): AxiosPromise<GenomeFragment> {
      return localVarFp.updateGenomeFragment(id, genomeFragment, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * GenomeFragmentResourceApi - object-oriented interface
 * @export
 * @class GenomeFragmentResourceApi
 * @extends {BaseAPI}
 */
export class GenomeFragmentResourceApi extends BaseAPI {
  /**
   *
   * @param {GenomeFragment} genomeFragment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public createGenomeFragment(genomeFragment: GenomeFragment, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .createGenomeFragment(genomeFragment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public deleteGenomeFragment(id: number, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .deleteGenomeFragment(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public getAllGenomeFragments(pageable: Pageable, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .getAllGenomeFragments(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public getGenomeFragment(id: number, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .getGenomeFragment(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {GenomeFragment} genomeFragment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public partialUpdateGenomeFragment(id: number, genomeFragment: GenomeFragment, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .partialUpdateGenomeFragment(id, genomeFragment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {GenomeFragment} genomeFragment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GenomeFragmentResourceApi
   */
  public updateGenomeFragment(id: number, genomeFragment: GenomeFragment, options?: AxiosRequestConfig) {
    return GenomeFragmentResourceApiFp(this.configuration)
      .updateGenomeFragment(id, genomeFragment, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * InfoResourceApi - axios parameter creator
 * @export
 */
export const InfoResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInfo: async (info: Info, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'info' is not null or undefined
      assertParamExists('createInfo', 'info', info);
      const localVarPath = `/api/infos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(info, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInfo: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteInfo', 'id', id);
      const localVarPath = `/api/infos/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInfos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/infos`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getInfo', 'id', id);
      const localVarPath = `/api/infos/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateInfo: async (id: number, info: Info, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateInfo', 'id', id);
      // verify required parameter 'info' is not null or undefined
      assertParamExists('partialUpdateInfo', 'info', info);
      const localVarPath = `/api/infos/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(info, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfo: async (id: number, info: Info, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateInfo', 'id', id);
      // verify required parameter 'info' is not null or undefined
      assertParamExists('updateInfo', 'info', info);
      const localVarPath = `/api/infos/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(info, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InfoResourceApi - functional programming interface
 * @export
 */
export const InfoResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InfoResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createInfo(info: Info, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createInfo(info, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInfo(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInfo(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllInfos(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Info>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInfos(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfo(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateInfo(
      id: number,
      info: Info,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateInfo(id, info, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInfo(
      id: number,
      info: Info,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateInfo(id, info, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * InfoResourceApi - factory interface
 * @export
 */
export const InfoResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = InfoResourceApiFp(configuration);
  return {
    /**
     *
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInfo(info: Info, options?: any): AxiosPromise<Info> {
      return localVarFp.createInfo(info, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInfo(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteInfo(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInfos(options?: any): AxiosPromise<Array<Info>> {
      return localVarFp.getAllInfos(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfo(id: number, options?: any): AxiosPromise<Info> {
      return localVarFp.getInfo(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateInfo(id: number, info: Info, options?: any): AxiosPromise<Info> {
      return localVarFp.partialUpdateInfo(id, info, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Info} info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfo(id: number, info: Info, options?: any): AxiosPromise<Info> {
      return localVarFp.updateInfo(id, info, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * InfoResourceApi - object-oriented interface
 * @export
 * @class InfoResourceApi
 * @extends {BaseAPI}
 */
export class InfoResourceApi extends BaseAPI {
  /**
   *
   * @param {Info} info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public createInfo(info: Info, options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .createInfo(info, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public deleteInfo(id: number, options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .deleteInfo(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public getAllInfos(options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .getAllInfos(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public getInfo(id: number, options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .getInfo(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Info} info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public partialUpdateInfo(id: number, info: Info, options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .partialUpdateInfo(id, info, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Info} info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoResourceApi
   */
  public updateInfo(id: number, info: Info, options?: AxiosRequestConfig) {
    return InfoResourceApiFp(this.configuration)
      .updateInfo(id, info, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * LogoutResourceApi - axios parameter creator
 * @export
 */
export const LogoutResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogoutResourceApi - functional programming interface
 * @export
 */
export const LogoutResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogoutResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LogoutResourceApi - factory interface
 * @export
 */
export const LogoutResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LogoutResourceApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<object> {
      return localVarFp.logout(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * LogoutResourceApi - object-oriented interface
 * @export
 * @class LogoutResourceApi
 * @extends {BaseAPI}
 */
export class LogoutResourceApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogoutResourceApi
   */
  public logout(options?: AxiosRequestConfig) {
    return LogoutResourceApiFp(this.configuration)
      .logout(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PipelineControllerApi - axios parameter creator
 * @export
 */
export const PipelineControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNcit: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/pipeline/update-ncit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePortalGene: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/pipeline/update-gene`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PipelineControllerApi - functional programming interface
 * @export
 */
export const PipelineControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PipelineControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateNcit(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateNcit(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePortalGene(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePortalGene(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PipelineControllerApi - factory interface
 * @export
 */
export const PipelineControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PipelineControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNcit(options?: any): AxiosPromise<void> {
      return localVarFp.updateNcit(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePortalGene(options?: any): AxiosPromise<void> {
      return localVarFp.updatePortalGene(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * PipelineControllerApi - object-oriented interface
 * @export
 * @class PipelineControllerApi
 * @extends {BaseAPI}
 */
export class PipelineControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PipelineControllerApi
   */
  public updateNcit(options?: AxiosRequestConfig) {
    return PipelineControllerApiFp(this.configuration)
      .updateNcit(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PipelineControllerApi
   */
  public updatePortalGene(options?: AxiosRequestConfig) {
    return PipelineControllerApiFp(this.configuration)
      .updatePortalGene(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SearchControllerApi - axios parameter creator
 * @export
 */
export const SearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('search', 'query', query);
      const localVarPath = `/api/_search/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchControllerApi - functional programming interface
 * @export
 */
export const SearchControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SearchControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async search(
      query: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.search(query, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SearchControllerApi - factory interface
 * @export
 */
export const SearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SearchControllerApiFp(configuration);
  return {
    /**
     *
     * @param {string} query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(query: string, options?: any): AxiosPromise<SearchResultDTO> {
      return localVarFp.search(query, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SearchControllerApi - object-oriented interface
 * @export
 * @class SearchControllerApi
 * @extends {BaseAPI}
 */
export class SearchControllerApi extends BaseAPI {
  /**
   *
   * @param {string} query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchControllerApi
   */
  public search(query: string, options?: AxiosRequestConfig) {
    return SearchControllerApiFp(this.configuration)
      .search(query, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SequenceControllerApi - axios parameter creator
 * @export
 */
export const SequenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequence: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findCanonicalSequence', 'referenceGenome', referenceGenome);
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('findCanonicalSequence', 'entrezGeneId', entrezGeneId);
      const localVarPath = `/api/find-canonical-sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (sequenceType !== undefined) {
        localVarQueryParameter['sequenceType'] = sequenceType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<number>} requestBody
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequences: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<number>,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findCanonicalSequences', 'referenceGenome', referenceGenome);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('findCanonicalSequences', 'requestBody', requestBody);
      const localVarPath = `/api/find-canonical-sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (sequenceType !== undefined) {
        localVarQueryParameter['sequenceType'] = sequenceType;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SequenceControllerApi - functional programming interface
 * @export
 */
export const SequenceControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SequenceControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findCanonicalSequence(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findCanonicalSequence(referenceGenome, entrezGeneId, sequenceType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<number>} requestBody
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findCanonicalSequences(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<number>,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sequence>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findCanonicalSequences(referenceGenome, requestBody, sequenceType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SequenceControllerApi - factory interface
 * @export
 */
export const SequenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SequenceControllerApiFp(configuration);
  return {
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {number} entrezGeneId
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequence(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options?: any
    ): AxiosPromise<Sequence> {
      return localVarFp
        .findCanonicalSequence(referenceGenome, entrezGeneId, sequenceType, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<number>} requestBody
     * @param {'PROTEIN' | 'CDNA'} [sequenceType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequences(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<number>,
      sequenceType?: 'PROTEIN' | 'CDNA',
      options?: any
    ): AxiosPromise<Array<Sequence>> {
      return localVarFp
        .findCanonicalSequences(referenceGenome, requestBody, sequenceType, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SequenceControllerApi - object-oriented interface
 * @export
 * @class SequenceControllerApi
 * @extends {BaseAPI}
 */
export class SequenceControllerApi extends BaseAPI {
  /**
   *
   * @param {'GRCh37' | 'GRCh38'} referenceGenome
   * @param {number} entrezGeneId
   * @param {'PROTEIN' | 'CDNA'} [sequenceType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceControllerApi
   */
  public findCanonicalSequence(
    referenceGenome: 'GRCh37' | 'GRCh38',
    entrezGeneId: number,
    sequenceType?: 'PROTEIN' | 'CDNA',
    options?: AxiosRequestConfig
  ) {
    return SequenceControllerApiFp(this.configuration)
      .findCanonicalSequence(referenceGenome, entrezGeneId, sequenceType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {'GRCh37' | 'GRCh38'} referenceGenome
   * @param {Array<number>} requestBody
   * @param {'PROTEIN' | 'CDNA'} [sequenceType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceControllerApi
   */
  public findCanonicalSequences(
    referenceGenome: 'GRCh37' | 'GRCh38',
    requestBody: Array<number>,
    sequenceType?: 'PROTEIN' | 'CDNA',
    options?: AxiosRequestConfig
  ) {
    return SequenceControllerApiFp(this.configuration)
      .findCanonicalSequences(referenceGenome, requestBody, sequenceType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SequenceResourceApi - axios parameter creator
 * @export
 */
export const SequenceResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSequence: async (sequence: Sequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'sequence' is not null or undefined
      assertParamExists('createSequence', 'sequence', sequence);
      const localVarPath = `/api/sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSequence: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSequence', 'id', id);
      const localVarPath = `/api/sequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSequences: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllSequences', 'pageable', pageable);
      const localVarPath = `/api/sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSequence: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSequence', 'id', id);
      const localVarPath = `/api/sequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateSequence: async (id: number, sequence: Sequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateSequence', 'id', id);
      // verify required parameter 'sequence' is not null or undefined
      assertParamExists('partialUpdateSequence', 'sequence', sequence);
      const localVarPath = `/api/sequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSequence: async (id: number, sequence: Sequence, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSequence', 'id', id);
      // verify required parameter 'sequence' is not null or undefined
      assertParamExists('updateSequence', 'sequence', sequence);
      const localVarPath = `/api/sequences/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sequence, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SequenceResourceApi - functional programming interface
 * @export
 */
export const SequenceResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SequenceResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSequence(
      sequence: Sequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSequence(sequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSequence(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSequence(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllSequences(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sequence>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSequences(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSequence(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSequence(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateSequence(
      id: number,
      sequence: Sequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSequence(id, sequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSequence(
      id: number,
      sequence: Sequence,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSequence(id, sequence, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SequenceResourceApi - factory interface
 * @export
 */
export const SequenceResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SequenceResourceApiFp(configuration);
  return {
    /**
     *
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSequence(sequence: Sequence, options?: any): AxiosPromise<Sequence> {
      return localVarFp.createSequence(sequence, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSequence(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteSequence(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSequences(pageable: Pageable, options?: any): AxiosPromise<Array<Sequence>> {
      return localVarFp.getAllSequences(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSequence(id: number, options?: any): AxiosPromise<Sequence> {
      return localVarFp.getSequence(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateSequence(id: number, sequence: Sequence, options?: any): AxiosPromise<Sequence> {
      return localVarFp.partialUpdateSequence(id, sequence, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {Sequence} sequence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSequence(id: number, sequence: Sequence, options?: any): AxiosPromise<Sequence> {
      return localVarFp.updateSequence(id, sequence, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SequenceResourceApi - object-oriented interface
 * @export
 * @class SequenceResourceApi
 * @extends {BaseAPI}
 */
export class SequenceResourceApi extends BaseAPI {
  /**
   *
   * @param {Sequence} sequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public createSequence(sequence: Sequence, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .createSequence(sequence, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public deleteSequence(id: number, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .deleteSequence(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public getAllSequences(pageable: Pageable, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .getAllSequences(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public getSequence(id: number, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .getSequence(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Sequence} sequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public partialUpdateSequence(id: number, sequence: Sequence, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .partialUpdateSequence(id, sequence, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {Sequence} sequence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceResourceApi
   */
  public updateSequence(id: number, sequence: Sequence, options?: AxiosRequestConfig) {
    return SequenceResourceApiFp(this.configuration)
      .updateSequence(id, sequence, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SpecimenTypeResourceApi - axios parameter creator
 * @export
 */
export const SpecimenTypeResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpecimenType: async (specimenType: SpecimenType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'specimenType' is not null or undefined
      assertParamExists('createSpecimenType', 'specimenType', specimenType);
      const localVarPath = `/api/specimen-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(specimenType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSpecimenType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteSpecimenType', 'id', id);
      const localVarPath = `/api/specimen-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSpecimenTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/specimen-types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpecimenType: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSpecimenType', 'id', id);
      const localVarPath = `/api/specimen-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateSpecimenType: async (id: number, specimenType: SpecimenType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateSpecimenType', 'id', id);
      // verify required parameter 'specimenType' is not null or undefined
      assertParamExists('partialUpdateSpecimenType', 'specimenType', specimenType);
      const localVarPath = `/api/specimen-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(specimenType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpecimenType: async (id: number, specimenType: SpecimenType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateSpecimenType', 'id', id);
      // verify required parameter 'specimenType' is not null or undefined
      assertParamExists('updateSpecimenType', 'specimenType', specimenType);
      const localVarPath = `/api/specimen-types/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(specimenType, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SpecimenTypeResourceApi - functional programming interface
 * @export
 */
export const SpecimenTypeResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SpecimenTypeResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSpecimenType(
      specimenType: SpecimenType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecimenType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSpecimenType(specimenType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSpecimenType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpecimenType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllSpecimenTypes(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecimenType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSpecimenTypes(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSpecimenType(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecimenType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecimenType(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateSpecimenType(
      id: number,
      specimenType: SpecimenType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecimenType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSpecimenType(id, specimenType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSpecimenType(
      id: number,
      specimenType: SpecimenType,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpecimenType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpecimenType(id, specimenType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SpecimenTypeResourceApi - factory interface
 * @export
 */
export const SpecimenTypeResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SpecimenTypeResourceApiFp(configuration);
  return {
    /**
     *
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSpecimenType(specimenType: SpecimenType, options?: any): AxiosPromise<SpecimenType> {
      return localVarFp.createSpecimenType(specimenType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSpecimenType(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteSpecimenType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllSpecimenTypes(options?: any): AxiosPromise<Array<SpecimenType>> {
      return localVarFp.getAllSpecimenTypes(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSpecimenType(id: number, options?: any): AxiosPromise<SpecimenType> {
      return localVarFp.getSpecimenType(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateSpecimenType(id: number, specimenType: SpecimenType, options?: any): AxiosPromise<SpecimenType> {
      return localVarFp.partialUpdateSpecimenType(id, specimenType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {SpecimenType} specimenType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSpecimenType(id: number, specimenType: SpecimenType, options?: any): AxiosPromise<SpecimenType> {
      return localVarFp.updateSpecimenType(id, specimenType, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SpecimenTypeResourceApi - object-oriented interface
 * @export
 * @class SpecimenTypeResourceApi
 * @extends {BaseAPI}
 */
export class SpecimenTypeResourceApi extends BaseAPI {
  /**
   *
   * @param {SpecimenType} specimenType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public createSpecimenType(specimenType: SpecimenType, options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .createSpecimenType(specimenType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public deleteSpecimenType(id: number, options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .deleteSpecimenType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public getAllSpecimenTypes(options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .getAllSpecimenTypes(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public getSpecimenType(id: number, options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .getSpecimenType(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {SpecimenType} specimenType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public partialUpdateSpecimenType(id: number, specimenType: SpecimenType, options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .partialUpdateSpecimenType(id, specimenType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {SpecimenType} specimenType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpecimenTypeResourceApi
   */
  public updateSpecimenType(id: number, specimenType: SpecimenType, options?: AxiosRequestConfig) {
    return SpecimenTypeResourceApiFp(this.configuration)
      .updateSpecimenType(id, specimenType, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TranscriptControllerApi - axios parameter creator
 * @export
 */
export const TranscriptControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {string} ensemblTranscriptId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranscript: async (
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('addTranscript', 'entrezGeneId', entrezGeneId);
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('addTranscript', 'referenceGenome', referenceGenome);
      // verify required parameter 'ensemblTranscriptId' is not null or undefined
      assertParamExists('addTranscript', 'ensemblTranscriptId', ensemblTranscriptId);
      // verify required parameter 'isCanonical' is not null or undefined
      assertParamExists('addTranscript', 'isCanonical', isCanonical);
      const localVarPath = `/api/add-transcript`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (ensemblTranscriptId !== undefined) {
        localVarQueryParameter['ensemblTranscriptId'] = ensemblTranscriptId;
      }

      if (isCanonical !== undefined) {
        localVarQueryParameter['isCanonical'] = isCanonical;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {TranscriptComparisonVM} transcriptComparisonVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareTranscript: async (
      hugoSymbol: string,
      transcriptComparisonVM: TranscriptComparisonVM,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('compareTranscript', 'hugoSymbol', hugoSymbol);
      // verify required parameter 'transcriptComparisonVM' is not null or undefined
      assertParamExists('compareTranscript', 'transcriptComparisonVM', transcriptComparisonVM);
      const localVarPath = `/api/compare-transcript/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transcriptComparisonVM, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTranscriptsByEnsemblIds: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findTranscriptsByEnsemblIds', 'referenceGenome', referenceGenome);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('findTranscriptsByEnsemblIds', 'requestBody', requestBody);
      const localVarPath = `/api/find-transcripts-by-ensembl-ids`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {MatchTranscriptVM} matchTranscriptVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchTranscript: async (
      hugoSymbol: string,
      matchTranscriptVM: MatchTranscriptVM,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('matchTranscript', 'hugoSymbol', hugoSymbol);
      // verify required parameter 'matchTranscriptVM' is not null or undefined
      assertParamExists('matchTranscript', 'matchTranscriptVM', matchTranscriptVM);
      const localVarPath = `/api/match-transcript/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(matchTranscriptVM, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {number} proteinPosition
     * @param {string} curatedResidue
     * @param {string} grch37Transcript
     * @param {string} grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestVariant: async (
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('suggestVariant', 'hugoSymbol', hugoSymbol);
      // verify required parameter 'proteinPosition' is not null or undefined
      assertParamExists('suggestVariant', 'proteinPosition', proteinPosition);
      // verify required parameter 'curatedResidue' is not null or undefined
      assertParamExists('suggestVariant', 'curatedResidue', curatedResidue);
      // verify required parameter 'grch37Transcript' is not null or undefined
      assertParamExists('suggestVariant', 'grch37Transcript', grch37Transcript);
      // verify required parameter 'grch38Transcript' is not null or undefined
      assertParamExists('suggestVariant', 'grch38Transcript', grch38Transcript);
      const localVarPath = `/api/suggest-variant/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (proteinPosition !== undefined) {
        localVarQueryParameter['proteinPosition'] = proteinPosition;
      }

      if (curatedResidue !== undefined) {
        localVarQueryParameter['curatedResidue'] = curatedResidue;
      }

      if (grch37Transcript !== undefined) {
        localVarQueryParameter['grch37Transcript'] = grch37Transcript;
      }

      if (grch38Transcript !== undefined) {
        localVarQueryParameter['grch38Transcript'] = grch38Transcript;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranscriptControllerApi - functional programming interface
 * @export
 */
export const TranscriptControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TranscriptControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {number} entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {string} ensemblTranscriptId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranscript(
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTranscript(
        entrezGeneId,
        referenceGenome,
        ensemblTranscriptId,
        isCanonical,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {TranscriptComparisonVM} transcriptComparisonVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async compareTranscript(
      hugoSymbol: string,
      transcriptComparisonVM: TranscriptComparisonVM,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptComparisonResultVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.compareTranscript(hugoSymbol, transcriptComparisonVM, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTranscriptsByEnsemblIds(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TranscriptDTO>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findTranscriptsByEnsemblIds(referenceGenome, requestBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {MatchTranscriptVM} matchTranscriptVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async matchTranscript(
      hugoSymbol: string,
      matchTranscriptVM: MatchTranscriptVM,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptMatchResultVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.matchTranscript(hugoSymbol, matchTranscriptVM, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {number} proteinPosition
     * @param {string} curatedResidue
     * @param {string} grch37Transcript
     * @param {string} grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestVariant(
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllReferenceTranscriptSuggestionVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.suggestVariant(
        hugoSymbol,
        proteinPosition,
        curatedResidue,
        grch37Transcript,
        grch38Transcript,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * TranscriptControllerApi - factory interface
 * @export
 */
export const TranscriptControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TranscriptControllerApiFp(configuration);
  return {
    /**
     *
     * @param {number} entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {string} ensemblTranscriptId
     * @param {boolean} isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranscript(
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options?: any
    ): AxiosPromise<TranscriptDTO> {
      return localVarFp
        .addTranscript(entrezGeneId, referenceGenome, ensemblTranscriptId, isCanonical, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {TranscriptComparisonVM} transcriptComparisonVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareTranscript(
      hugoSymbol: string,
      transcriptComparisonVM: TranscriptComparisonVM,
      options?: any
    ): AxiosPromise<TranscriptComparisonResultVM> {
      return localVarFp.compareTranscript(hugoSymbol, transcriptComparisonVM, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {'GRCh37' | 'GRCh38'} referenceGenome
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTranscriptsByEnsemblIds(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<Array<TranscriptDTO>> {
      return localVarFp.findTranscriptsByEnsemblIds(referenceGenome, requestBody, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {MatchTranscriptVM} matchTranscriptVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchTranscript(hugoSymbol: string, matchTranscriptVM: MatchTranscriptVM, options?: any): AxiosPromise<TranscriptMatchResultVM> {
      return localVarFp.matchTranscript(hugoSymbol, matchTranscriptVM, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} hugoSymbol
     * @param {number} proteinPosition
     * @param {string} curatedResidue
     * @param {string} grch37Transcript
     * @param {string} grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestVariant(
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options?: any
    ): AxiosPromise<AllReferenceTranscriptSuggestionVM> {
      return localVarFp
        .suggestVariant(hugoSymbol, proteinPosition, curatedResidue, grch37Transcript, grch38Transcript, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TranscriptControllerApi - object-oriented interface
 * @export
 * @class TranscriptControllerApi
 * @extends {BaseAPI}
 */
export class TranscriptControllerApi extends BaseAPI {
  /**
   *
   * @param {number} entrezGeneId
   * @param {'GRCh37' | 'GRCh38'} referenceGenome
   * @param {string} ensemblTranscriptId
   * @param {boolean} isCanonical
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public addTranscript(
    entrezGeneId: number,
    referenceGenome: 'GRCh37' | 'GRCh38',
    ensemblTranscriptId: string,
    isCanonical: boolean,
    options?: AxiosRequestConfig
  ) {
    return TranscriptControllerApiFp(this.configuration)
      .addTranscript(entrezGeneId, referenceGenome, ensemblTranscriptId, isCanonical, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} hugoSymbol
   * @param {TranscriptComparisonVM} transcriptComparisonVM
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public compareTranscript(hugoSymbol: string, transcriptComparisonVM: TranscriptComparisonVM, options?: AxiosRequestConfig) {
    return TranscriptControllerApiFp(this.configuration)
      .compareTranscript(hugoSymbol, transcriptComparisonVM, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {'GRCh37' | 'GRCh38'} referenceGenome
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public findTranscriptsByEnsemblIds(referenceGenome: 'GRCh37' | 'GRCh38', requestBody: Array<string>, options?: AxiosRequestConfig) {
    return TranscriptControllerApiFp(this.configuration)
      .findTranscriptsByEnsemblIds(referenceGenome, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} hugoSymbol
   * @param {MatchTranscriptVM} matchTranscriptVM
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public matchTranscript(hugoSymbol: string, matchTranscriptVM: MatchTranscriptVM, options?: AxiosRequestConfig) {
    return TranscriptControllerApiFp(this.configuration)
      .matchTranscript(hugoSymbol, matchTranscriptVM, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} hugoSymbol
   * @param {number} proteinPosition
   * @param {string} curatedResidue
   * @param {string} grch37Transcript
   * @param {string} grch38Transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public suggestVariant(
    hugoSymbol: string,
    proteinPosition: number,
    curatedResidue: string,
    grch37Transcript: string,
    grch38Transcript: string,
    options?: AxiosRequestConfig
  ) {
    return TranscriptControllerApiFp(this.configuration)
      .suggestVariant(hugoSymbol, proteinPosition, curatedResidue, grch37Transcript, grch38Transcript, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TranscriptResourceApi - axios parameter creator
 * @export
 */
export const TranscriptResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranscript: async (transcriptDTO: TranscriptDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'transcriptDTO' is not null or undefined
      assertParamExists('createTranscript', 'transcriptDTO', transcriptDTO);
      const localVarPath = `/api/transcripts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transcriptDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranscript: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteTranscript', 'id', id);
      const localVarPath = `/api/transcripts/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTranscripts: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllTranscripts', 'pageable', pageable);
      const localVarPath = `/api/transcripts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranscript: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getTranscript', 'id', id);
      const localVarPath = `/api/transcripts/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateTranscript: async (id: number, transcriptDTO: TranscriptDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('partialUpdateTranscript', 'id', id);
      // verify required parameter 'transcriptDTO' is not null or undefined
      assertParamExists('partialUpdateTranscript', 'transcriptDTO', transcriptDTO);
      const localVarPath = `/api/transcripts/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transcriptDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTranscript: async (id: number, transcriptDTO: TranscriptDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateTranscript', 'id', id);
      // verify required parameter 'transcriptDTO' is not null or undefined
      assertParamExists('updateTranscript', 'transcriptDTO', transcriptDTO);
      const localVarPath = `/api/transcripts/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transcriptDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranscriptResourceApi - functional programming interface
 * @export
 */
export const TranscriptResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TranscriptResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTranscript(
      transcriptDTO: TranscriptDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTranscript(transcriptDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTranscript(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTranscript(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllTranscripts(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TranscriptDTO>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTranscripts(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranscript(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscript(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async partialUpdateTranscript(
      id: number,
      transcriptDTO: TranscriptDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateTranscript(id, transcriptDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTranscript(
      id: number,
      transcriptDTO: TranscriptDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranscript(id, transcriptDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * TranscriptResourceApi - factory interface
 * @export
 */
export const TranscriptResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TranscriptResourceApiFp(configuration);
  return {
    /**
     *
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTranscript(transcriptDTO: TranscriptDTO, options?: any): AxiosPromise<TranscriptDTO> {
      return localVarFp.createTranscript(transcriptDTO, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTranscript(id: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteTranscript(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTranscripts(pageable: Pageable, options?: any): AxiosPromise<Array<TranscriptDTO>> {
      return localVarFp.getAllTranscripts(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranscript(id: number, options?: any): AxiosPromise<TranscriptDTO> {
      return localVarFp.getTranscript(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    partialUpdateTranscript(id: number, transcriptDTO: TranscriptDTO, options?: any): AxiosPromise<TranscriptDTO> {
      return localVarFp.partialUpdateTranscript(id, transcriptDTO, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {TranscriptDTO} transcriptDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTranscript(id: number, transcriptDTO: TranscriptDTO, options?: any): AxiosPromise<TranscriptDTO> {
      return localVarFp.updateTranscript(id, transcriptDTO, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * TranscriptResourceApi - object-oriented interface
 * @export
 * @class TranscriptResourceApi
 * @extends {BaseAPI}
 */
export class TranscriptResourceApi extends BaseAPI {
  /**
   *
   * @param {TranscriptDTO} transcriptDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public createTranscript(transcriptDTO: TranscriptDTO, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .createTranscript(transcriptDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public deleteTranscript(id: number, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .deleteTranscript(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public getAllTranscripts(pageable: Pageable, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .getAllTranscripts(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public getTranscript(id: number, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .getTranscript(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {TranscriptDTO} transcriptDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public partialUpdateTranscript(id: number, transcriptDTO: TranscriptDTO, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .partialUpdateTranscript(id, transcriptDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {TranscriptDTO} transcriptDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptResourceApi
   */
  public updateTranscript(id: number, transcriptDTO: TranscriptDTO, options?: AxiosRequestConfig) {
    return TranscriptResourceApiFp(this.configuration)
      .updateTranscript(id, transcriptDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserResourceApi - axios parameter creator
 * @export
 */
export const UserResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (userDTO: UserDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userDTO' is not null or undefined
      assertParamExists('createUser', 'userDTO', userDTO);
      const localVarPath = `/api/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (login: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'login' is not null or undefined
      assertParamExists('deleteUser', 'login', login);
      const localVarPath = `/api/admin/users/{login}`.replace(`{${'login'}}`, encodeURIComponent(String(login)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers: async (pageable: Pageable, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pageable' is not null or undefined
      assertParamExists('getAllUsers', 'pageable', pageable);
      const localVarPath = `/api/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pageable !== undefined) {
        localVarQueryParameter['pageable'] = pageable;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (login: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'login' is not null or undefined
      assertParamExists('getUser', 'login', login);
      const localVarPath = `/api/admin/users/{login}`.replace(`{${'login'}}`, encodeURIComponent(String(login)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (id: number, userDTO: UserDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateUser', 'id', id);
      // verify required parameter 'userDTO' is not null or undefined
      assertParamExists('updateUser', 'userDTO', userDTO);
      const localVarPath = `/api/admin/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserResourceApi - functional programming interface
 * @export
 */
export const UserResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      userDTO: UserDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      login: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(login, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsers(
      pageable: Pageable,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(pageable, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      login: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(login, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      id: number,
      userDTO: UserDTO,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userDTO, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserResourceApi - factory interface
 * @export
 */
export const UserResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserResourceApiFp(configuration);
  return {
    /**
     *
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(userDTO: UserDTO, options?: any): AxiosPromise<User> {
      return localVarFp.createUser(userDTO, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(login: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleteUser(login, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {Pageable} pageable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsers(pageable: Pageable, options?: any): AxiosPromise<Array<UserDTO>> {
      return localVarFp.getAllUsers(pageable, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(login: string, options?: any): AxiosPromise<UserDTO> {
      return localVarFp.getUser(login, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {UserDTO} userDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: number, userDTO: UserDTO, options?: any): AxiosPromise<UserDTO> {
      return localVarFp.updateUser(id, userDTO, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserResourceApi - object-oriented interface
 * @export
 * @class UserResourceApi
 * @extends {BaseAPI}
 */
export class UserResourceApi extends BaseAPI {
  /**
   *
   * @param {UserDTO} userDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public createUser(userDTO: UserDTO, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .createUser(userDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public deleteUser(login: string, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .deleteUser(login, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Pageable} pageable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public getAllUsers(pageable: Pageable, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .getAllUsers(pageable, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public getUser(login: string, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .getUser(login, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {UserDTO} userDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public updateUser(id: number, userDTO: UserDTO, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .updateUser(id, userDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}
