/* tslint:disable */
/* eslint-disable */
/**
 * oncokb-curation API
 * oncokb-curation API documentation
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AllReferenceTranscriptSuggestionVM
 */
export interface AllReferenceTranscriptSuggestionVM {
  /**
   *
   * @type {TranscriptSuggestionVM}
   * @memberof AllReferenceTranscriptSuggestionVM
   */
  grch37?: TranscriptSuggestionVM;
  /**
   *
   * @type {TranscriptSuggestionVM}
   * @memberof AllReferenceTranscriptSuggestionVM
   */
  grch38?: TranscriptSuggestionVM;
}
/**
 *
 * @export
 * @interface AuthInfoVM
 */
export interface AuthInfoVM {
  /**
   *
   * @type {string}
   * @memberof AuthInfoVM
   */
  clientId?: string;
  /**
   *
   * @type {string}
   * @memberof AuthInfoVM
   */
  issuer?: string;
}
/**
 *
 * @export
 * @interface Drug
 */
export interface Drug {
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  code?: string;
  /**
   *
   * @type {number}
   * @memberof Drug
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  semanticType?: string;
  /**
   *
   * @type {Set<DrugSynonym>}
   * @memberof Drug
   */
  synonyms?: Set<DrugSynonym>;
}
/**
 *
 * @export
 * @interface DrugSynonym
 */
export interface DrugSynonym {
  /**
   *
   * @type {Drug}
   * @memberof DrugSynonym
   */
  drug?: Drug;
  /**
   *
   * @type {number}
   * @memberof DrugSynonym
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof DrugSynonym
   */
  name?: string;
}
/**
 *
 * @export
 * @interface EnsemblGene
 */
export interface EnsemblGene {
  /**
   *
   * @type {boolean}
   * @memberof EnsemblGene
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  chromosome: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  end: number;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  ensemblGeneId: string;
  /**
   *
   * @type {Gene}
   * @memberof EnsemblGene
   */
  gene?: Gene;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  referenceGenome: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  start: number;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  strand: number;
  /**
   *
   * @type {Set<Transcript>}
   * @memberof EnsemblGene
   */
  transcripts?: Set<Transcript>;
}
/**
 *
 * @export
 * @interface EnsemblTranscript
 */
export interface EnsemblTranscript {
  /**
   * Consensus CDS (CCDS) ID
   * @type {string}
   * @memberof EnsemblTranscript
   */
  ccdsId?: string;
  /**
   * Exon information
   * @type {Array<Exon>}
   * @memberof EnsemblTranscript
   */
  exons?: Array<Exon>;
  /**
   * Ensembl gene id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  geneId: string;
  /**
   * Hugo symbols
   * @type {Array<string>}
   * @memberof EnsemblTranscript
   */
  hugoSymbols?: Array<string>;
  /**
   * Pfam domains
   * @type {Array<PfamDomainRange>}
   * @memberof EnsemblTranscript
   */
  pfamDomains?: Array<PfamDomainRange>;
  /**
   * Ensembl protein id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  proteinId: string;
  /**
   * Length of protein
   * @type {number}
   * @memberof EnsemblTranscript
   */
  proteinLength?: number;
  /**
   * RefSeq mRNA ID
   * @type {string}
   * @memberof EnsemblTranscript
   */
  refseqMrnaId?: string;
  /**
   * Ensembl transcript id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  transcriptId: string;
  /**
   * UTR information
   * @type {Array<UntranslatedRegion>}
   * @memberof EnsemblTranscript
   */
  utrs?: Array<UntranslatedRegion>;
}
/**
 *
 * @export
 * @interface Exon
 */
export interface Exon {
  /**
   * End position of exon
   * @type {number}
   * @memberof Exon
   */
  exonEnd: number;
  /**
   * Exon id
   * @type {string}
   * @memberof Exon
   */
  exonId: string;
  /**
   * Start position of exon
   * @type {number}
   * @memberof Exon
   */
  exonStart: number;
  /**
   * Number of exon in transcript
   * @type {number}
   * @memberof Exon
   */
  rank: number;
  /**
   * Strand exon is on, -1 for - and 1 for +
   * @type {number}
   * @memberof Exon
   */
  strand: number;
  /**
   * Exon version
   * @type {number}
   * @memberof Exon
   */
  version: number;
}
/**
 *
 * @export
 * @interface Gene
 */
export interface Gene {
  /**
   *
   * @type {Set<EnsemblGene>}
   * @memberof Gene
   */
  ensemblGenes?: Set<EnsemblGene>;
  /**
   *
   * @type {number}
   * @memberof Gene
   */
  entrezGeneId?: number;
  /**
   *
   * @type {Set<GeneAlias>}
   * @memberof Gene
   */
  geneAliases?: Set<GeneAlias>;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  hugoSymbol?: string;
  /**
   *
   * @type {number}
   * @memberof Gene
   */
  id?: number;
}
/**
 *
 * @export
 * @interface GeneAlias
 */
export interface GeneAlias {
  /**
   *
   * @type {Gene}
   * @memberof GeneAlias
   */
  gene?: Gene;
  /**
   *
   * @type {number}
   * @memberof GeneAlias
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof GeneAlias
   */
  name?: string;
}
/**
 *
 * @export
 * @interface GenomeFragment
 */
export interface GenomeFragment {
  /**
   *
   * @type {string}
   * @memberof GenomeFragment
   */
  chromosome?: string;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  end?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeFragment
   */
  strand?: number;
  /**
   *
   * @type {Transcript}
   * @memberof GenomeFragment
   */
  transcript?: Transcript;
  /**
   *
   * @type {string}
   * @memberof GenomeFragment
   */
  type?: GenomeFragmentTypeEnum;
}

export const GenomeFragmentTypeEnum = {
  Exon: 'EXON',
  FivePrimeUtr: 'FIVE_PRIME_UTR',
  Gene: 'GENE',
  ThreePrimeUtr: 'THREE_PRIME_UTR',
} as const;

export type GenomeFragmentTypeEnum = typeof GenomeFragmentTypeEnum[keyof typeof GenomeFragmentTypeEnum];

/**
 *
 * @export
 * @interface MatchTranscriptVM
 */
export interface MatchTranscriptVM {
  /**
   *
   * @type {string}
   * @memberof MatchTranscriptVM
   */
  targetReferenceGenome?: MatchTranscriptVMTargetReferenceGenomeEnum;
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof MatchTranscriptVM
   */
  transcript?: TranscriptPairVM;
}

export const MatchTranscriptVMTargetReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type MatchTranscriptVMTargetReferenceGenomeEnum =
  typeof MatchTranscriptVMTargetReferenceGenomeEnum[keyof typeof MatchTranscriptVMTargetReferenceGenomeEnum];

/**
 *
 * @export
 * @interface PfamDomainRange
 */
export interface PfamDomainRange {
  /**
   * Pfam domain end amino acid
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainEnd: number;
  /**
   * Pfam domain id
   * @type {string}
   * @memberof PfamDomainRange
   */
  pfamDomainId: string;
  /**
   * Pfam domain start amino acid
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainStart: number;
}
/**
 *
 * @export
 * @interface Sequence
 */
export interface Sequence {
  /**
   *
   * @type {number}
   * @memberof Sequence
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Sequence
   */
  sequence?: string;
  /**
   *
   * @type {string}
   * @memberof Sequence
   */
  sequenceType?: SequenceSequenceTypeEnum;
  /**
   *
   * @type {Transcript}
   * @memberof Sequence
   */
  transcript?: Transcript;
}

export const SequenceSequenceTypeEnum = {
  Cdna: 'CDNA',
  Protein: 'PROTEIN',
} as const;

export type SequenceSequenceTypeEnum = typeof SequenceSequenceTypeEnum[keyof typeof SequenceSequenceTypeEnum];

/**
 *
 * @export
 * @interface Transcript
 */
export interface Transcript {
  /**
   *
   * @type {boolean}
   * @memberof Transcript
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  description?: string;
  /**
   *
   * @type {EnsemblGene}
   * @memberof Transcript
   */
  ensemblGene?: EnsemblGene;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  ensemblProteinId?: string;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  ensemblTranscriptId?: string;
  /**
   *
   * @type {Set<GenomeFragment>}
   * @memberof Transcript
   */
  fragments?: Set<GenomeFragment>;
  /**
   *
   * @type {number}
   * @memberof Transcript
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Transcript
   */
  referenceSequenceId?: string;
  /**
   *
   * @type {Set<Sequence>}
   * @memberof Transcript
   */
  sequences?: Set<Sequence>;
}
/**
 *
 * @export
 * @interface TranscriptComparisonResultVM
 */
export interface TranscriptComparisonResultVM {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptComparisonResultVM
   */
  match?: boolean;
  /**
   *
   * @type {string}
   * @memberof TranscriptComparisonResultVM
   */
  sequenceA?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptComparisonResultVM
   */
  sequenceB?: string;
}
/**
 *
 * @export
 * @interface TranscriptComparisonVM
 */
export interface TranscriptComparisonVM {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptComparisonVM
   */
  align?: boolean;
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof TranscriptComparisonVM
   */
  transcriptA?: TranscriptPairVM;
  /**
   *
   * @type {TranscriptPairVM}
   * @memberof TranscriptComparisonVM
   */
  transcriptB?: TranscriptPairVM;
}
/**
 *
 * @export
 * @interface TranscriptDTO
 */
export interface TranscriptDTO {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptDTO
   */
  canonical: boolean;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  chromosome?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  end?: number;
  /**
   *
   * @type {EnsemblGene}
   * @memberof TranscriptDTO
   */
  ensemblGene?: EnsemblGene;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  ensemblProteinId?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  ensemblTranscriptId?: string;
  /**
   *
   * @type {Array<GenomeFragment>}
   * @memberof TranscriptDTO
   */
  exons?: Array<GenomeFragment>;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof TranscriptDTO
   */
  referenceSequenceId?: string;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof TranscriptDTO
   */
  strand?: number;
  /**
   *
   * @type {Array<GenomeFragment>}
   * @memberof TranscriptDTO
   */
  utrs?: Array<GenomeFragment>;
}
/**
 *
 * @export
 * @interface TranscriptMatchResultVM
 */
export interface TranscriptMatchResultVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptMatchResultVM
   */
  note?: string;
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptMatchResultVM
   */
  originalEnsemblTranscript?: EnsemblTranscript;
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptMatchResultVM
   */
  targetEnsemblTranscript?: EnsemblTranscript;
}
/**
 *
 * @export
 * @interface TranscriptPairVM
 */
export interface TranscriptPairVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptPairVM
   */
  referenceGenome?: TranscriptPairVMReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof TranscriptPairVM
   */
  transcript?: string;
}

export const TranscriptPairVMReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type TranscriptPairVMReferenceGenomeEnum =
  typeof TranscriptPairVMReferenceGenomeEnum[keyof typeof TranscriptPairVMReferenceGenomeEnum];

/**
 *
 * @export
 * @interface TranscriptSuggestionVM
 */
export interface TranscriptSuggestionVM {
  /**
   *
   * @type {string}
   * @memberof TranscriptSuggestionVM
   */
  note?: string;
  /**
   *
   * @type {string}
   * @memberof TranscriptSuggestionVM
   */
  referenceGenome?: TranscriptSuggestionVMReferenceGenomeEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof TranscriptSuggestionVM
   */
  suggestions?: Array<string>;
}

export const TranscriptSuggestionVMReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type TranscriptSuggestionVMReferenceGenomeEnum =
  typeof TranscriptSuggestionVMReferenceGenomeEnum[keyof typeof TranscriptSuggestionVMReferenceGenomeEnum];

/**
 *
 * @export
 * @interface UntranslatedRegion
 */
export interface UntranslatedRegion {
  /**
   * End position of UTR
   * @type {number}
   * @memberof UntranslatedRegion
   */
  end: number;
  /**
   * Start position of UTR
   * @type {number}
   * @memberof UntranslatedRegion
   */
  start: number;
  /**
   * Strand UTR is on, -1 for - and 1 for +
   * @type {number}
   * @memberof UntranslatedRegion
   */
  strand: number;
  /**
   * UTR Type
   * @type {string}
   * @memberof UntranslatedRegion
   */
  type: string;
}
/**
 *
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
  /**
   *
   * @type {boolean}
   * @memberof UserDTO
   */
  activated?: boolean;
  /**
   *
   * @type {Set<string>}
   * @memberof UserDTO
   */
  authorities?: Set<string>;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  createdDate?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  firstName?: string;
  /**
   *
   * @type {number}
   * @memberof UserDTO
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  imageUrl?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  langKey?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastModifiedBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastModifiedDate?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof UserDTO
   */
  login: string;
}

/**
 * AccountResourceApi - axios parameter creator
 * @export
 */
export const AccountResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary getAccount
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountUsingGET: async (name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary isAuthenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAuthenticatedUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/authenticate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountResourceApi - functional programming interface
 * @export
 */
export const AccountResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getAccount
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountUsingGET(
      name?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountUsingGET(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary isAuthenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isAuthenticatedUsingGET(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isAuthenticatedUsingGET(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AccountResourceApi - factory interface
 * @export
 */
export const AccountResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AccountResourceApiFp(configuration);
  return {
    /**
     *
     * @summary getAccount
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountUsingGET(name?: string, options?: any): AxiosPromise<UserDTO> {
      return localVarFp.getAccountUsingGET(name, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary isAuthenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAuthenticatedUsingGET(options?: any): AxiosPromise<string> {
      return localVarFp.isAuthenticatedUsingGET(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AccountResourceApi - object-oriented interface
 * @export
 * @class AccountResourceApi
 * @extends {BaseAPI}
 */
export class AccountResourceApi extends BaseAPI {
  /**
   *
   * @summary getAccount
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountResourceApi
   */
  public getAccountUsingGET(name?: string, options?: AxiosRequestConfig) {
    return AccountResourceApiFp(this.configuration)
      .getAccountUsingGET(name, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary isAuthenticated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountResourceApi
   */
  public isAuthenticatedUsingGET(options?: AxiosRequestConfig) {
    return AccountResourceApiFp(this.configuration)
      .isAuthenticatedUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * AuthInfoResourceApi - axios parameter creator
 * @export
 */
export const AuthInfoResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary getAuthInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthInfoUsingGET: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth-info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthInfoResourceApi - functional programming interface
 * @export
 */
export const AuthInfoResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthInfoResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getAuthInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthInfoUsingGET(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfoVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfoUsingGET(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthInfoResourceApi - factory interface
 * @export
 */
export const AuthInfoResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthInfoResourceApiFp(configuration);
  return {
    /**
     *
     * @summary getAuthInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthInfoUsingGET(options?: any): AxiosPromise<AuthInfoVM> {
      return localVarFp.getAuthInfoUsingGET(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AuthInfoResourceApi - object-oriented interface
 * @export
 * @class AuthInfoResourceApi
 * @extends {BaseAPI}
 */
export class AuthInfoResourceApi extends BaseAPI {
  /**
   *
   * @summary getAuthInfo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthInfoResourceApi
   */
  public getAuthInfoUsingGET(options?: AxiosRequestConfig) {
    return AuthInfoResourceApiFp(this.configuration)
      .getAuthInfoUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DrugControllerApi - axios parameter creator
 * @export
 */
export const DrugControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary findDrugByCode
     * @param {string} code code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugByCodeUsingGET: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists('findDrugByCodeUsingGET', 'code', code);
      const localVarPath = `/api/drugs/search-by-code/{code}`.replace(`{${'code'}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary findDrugs
     * @param {string} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugsUsingGET: async (query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('findDrugsUsingGET', 'query', query);
      const localVarPath = `/api/drugs/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugControllerApi - functional programming interface
 * @export
 */
export const DrugControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary findDrugByCode
     * @param {string} code code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDrugByCodeUsingGET(
      code: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Drug>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findDrugByCodeUsingGET(code, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary findDrugs
     * @param {string} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDrugsUsingGET(
      query: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findDrugsUsingGET(query, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DrugControllerApi - factory interface
 * @export
 */
export const DrugControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugControllerApiFp(configuration);
  return {
    /**
     *
     * @summary findDrugByCode
     * @param {string} code code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugByCodeUsingGET(code: string, options?: any): AxiosPromise<Drug> {
      return localVarFp.findDrugByCodeUsingGET(code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary findDrugs
     * @param {string} query query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDrugsUsingGET(query: string, options?: any): AxiosPromise<Array<Drug>> {
      return localVarFp.findDrugsUsingGET(query, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugControllerApi - object-oriented interface
 * @export
 * @class DrugControllerApi
 * @extends {BaseAPI}
 */
export class DrugControllerApi extends BaseAPI {
  /**
   *
   * @summary findDrugByCode
   * @param {string} code code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugControllerApi
   */
  public findDrugByCodeUsingGET(code: string, options?: AxiosRequestConfig) {
    return DrugControllerApiFp(this.configuration)
      .findDrugByCodeUsingGET(code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary findDrugs
   * @param {string} query query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugControllerApi
   */
  public findDrugsUsingGET(query: string, options?: AxiosRequestConfig) {
    return DrugControllerApiFp(this.configuration)
      .findDrugsUsingGET(query, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EnsemblGeneControllerApi - axios parameter creator
 * @export
 */
export const EnsemblGeneControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary addEnsemblGene
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {string} ensemblGeneId ensemblGeneId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEnsemblGeneUsingPOST: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('addEnsemblGeneUsingPOST', 'referenceGenome', referenceGenome);
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('addEnsemblGeneUsingPOST', 'entrezGeneId', entrezGeneId);
      // verify required parameter 'ensemblGeneId' is not null or undefined
      assertParamExists('addEnsemblGeneUsingPOST', 'ensemblGeneId', ensemblGeneId);
      // verify required parameter 'isCanonical' is not null or undefined
      assertParamExists('addEnsemblGeneUsingPOST', 'isCanonical', isCanonical);
      const localVarPath = `/api/add-ensembl-gene`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (ensemblGeneId !== undefined) {
        localVarQueryParameter['ensemblGeneId'] = ensemblGeneId;
      }

      if (isCanonical !== undefined) {
        localVarQueryParameter['isCanonical'] = isCanonical;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnsemblGeneControllerApi - functional programming interface
 * @export
 */
export const EnsemblGeneControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnsemblGeneControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary addEnsemblGene
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {string} ensemblGeneId ensemblGeneId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addEnsemblGeneUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnsemblGene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addEnsemblGeneUsingPOST(
        referenceGenome,
        entrezGeneId,
        ensemblGeneId,
        isCanonical,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EnsemblGeneControllerApi - factory interface
 * @export
 */
export const EnsemblGeneControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EnsemblGeneControllerApiFp(configuration);
  return {
    /**
     *
     * @summary addEnsemblGene
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {string} ensemblGeneId ensemblGeneId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEnsemblGeneUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      ensemblGeneId: string,
      isCanonical: boolean,
      options?: any
    ): AxiosPromise<EnsemblGene> {
      return localVarFp
        .addEnsemblGeneUsingPOST(referenceGenome, entrezGeneId, ensemblGeneId, isCanonical, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * EnsemblGeneControllerApi - object-oriented interface
 * @export
 * @class EnsemblGeneControllerApi
 * @extends {BaseAPI}
 */
export class EnsemblGeneControllerApi extends BaseAPI {
  /**
   *
   * @summary addEnsemblGene
   * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
   * @param {number} entrezGeneId entrezGeneId
   * @param {string} ensemblGeneId ensemblGeneId
   * @param {boolean} isCanonical isCanonical
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnsemblGeneControllerApi
   */
  public addEnsemblGeneUsingPOST(
    referenceGenome: 'GRCh37' | 'GRCh38',
    entrezGeneId: number,
    ensemblGeneId: string,
    isCanonical: boolean,
    options?: AxiosRequestConfig
  ) {
    return EnsemblGeneControllerApiFp(this.configuration)
      .addEnsemblGeneUsingPOST(referenceGenome, entrezGeneId, ensemblGeneId, isCanonical, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * GeneControllerApi - axios parameter creator
 * @export
 */
export const GeneControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary findGeneBySymbol
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGeneBySymbolUsingGET: async (symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      assertParamExists('findGeneBySymbolUsingGET', 'symbol', symbol);
      const localVarPath = `/api/find-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (symbol !== undefined) {
        localVarQueryParameter['symbol'] = symbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary findGenesBySymbols
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGenesBySymbolsUsingPOST: async (requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/find-genes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneControllerApi - functional programming interface
 * @export
 */
export const GeneControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary findGeneBySymbol
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGeneBySymbolUsingGET(
      symbol: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gene>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGeneBySymbolUsingGET(symbol, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary findGenesBySymbols
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findGenesBySymbolsUsingPOST(
      requestBody?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Gene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findGenesBySymbolsUsingPOST(requestBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * GeneControllerApi - factory interface
 * @export
 */
export const GeneControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GeneControllerApiFp(configuration);
  return {
    /**
     *
     * @summary findGeneBySymbol
     * @param {string} symbol symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGeneBySymbolUsingGET(symbol: string, options?: any): AxiosPromise<Gene> {
      return localVarFp.findGeneBySymbolUsingGET(symbol, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary findGenesBySymbols
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findGenesBySymbolsUsingPOST(requestBody?: Array<string>, options?: any): AxiosPromise<Set<Gene>> {
      return localVarFp.findGenesBySymbolsUsingPOST(requestBody, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * GeneControllerApi - object-oriented interface
 * @export
 * @class GeneControllerApi
 * @extends {BaseAPI}
 */
export class GeneControllerApi extends BaseAPI {
  /**
   *
   * @summary findGeneBySymbol
   * @param {string} symbol symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneControllerApi
   */
  public findGeneBySymbolUsingGET(symbol: string, options?: AxiosRequestConfig) {
    return GeneControllerApiFp(this.configuration)
      .findGeneBySymbolUsingGET(symbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary findGenesBySymbols
   * @param {Array<string>} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneControllerApi
   */
  public findGenesBySymbolsUsingPOST(requestBody?: Array<string>, options?: AxiosRequestConfig) {
    return GeneControllerApiFp(this.configuration)
      .findGenesBySymbolsUsingPOST(requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * LogoutResourceApi - axios parameter creator
 * @export
 */
export const LogoutResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogoutResourceApi - functional programming interface
 * @export
 */
export const LogoutResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogoutResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUsingPOST(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LogoutResourceApi - factory interface
 * @export
 */
export const LogoutResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LogoutResourceApiFp(configuration);
  return {
    /**
     *
     * @summary logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutUsingPOST(options?: any): AxiosPromise<object> {
      return localVarFp.logoutUsingPOST(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * LogoutResourceApi - object-oriented interface
 * @export
 * @class LogoutResourceApi
 * @extends {BaseAPI}
 */
export class LogoutResourceApi extends BaseAPI {
  /**
   *
   * @summary logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogoutResourceApi
   */
  public logoutUsingPOST(options?: AxiosRequestConfig) {
    return LogoutResourceApiFp(this.configuration)
      .logoutUsingPOST(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PipelineControllerApi - axios parameter creator
 * @export
 */
export const PipelineControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary updateNcit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNcitUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/pipeline/update-ncit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary updatePortalGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePortalGeneUsingPOST: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/pipeline/update-gene`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PipelineControllerApi - functional programming interface
 * @export
 */
export const PipelineControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PipelineControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary updateNcit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateNcitUsingPOST(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateNcitUsingPOST(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary updatePortalGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePortalGeneUsingPOST(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePortalGeneUsingPOST(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PipelineControllerApi - factory interface
 * @export
 */
export const PipelineControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PipelineControllerApiFp(configuration);
  return {
    /**
     *
     * @summary updateNcit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNcitUsingPOST(options?: any): AxiosPromise<void> {
      return localVarFp.updateNcitUsingPOST(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary updatePortalGene
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePortalGeneUsingPOST(options?: any): AxiosPromise<void> {
      return localVarFp.updatePortalGeneUsingPOST(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * PipelineControllerApi - object-oriented interface
 * @export
 * @class PipelineControllerApi
 * @extends {BaseAPI}
 */
export class PipelineControllerApi extends BaseAPI {
  /**
   *
   * @summary updateNcit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PipelineControllerApi
   */
  public updateNcitUsingPOST(options?: AxiosRequestConfig) {
    return PipelineControllerApiFp(this.configuration)
      .updateNcitUsingPOST(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary updatePortalGene
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PipelineControllerApi
   */
  public updatePortalGeneUsingPOST(options?: AxiosRequestConfig) {
    return PipelineControllerApiFp(this.configuration)
      .updatePortalGeneUsingPOST(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SequenceControllerApi - axios parameter creator
 * @export
 */
export const SequenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary findCanonicalSequence
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequenceUsingGET: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'CDNA' | 'PROTEIN',
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findCanonicalSequenceUsingGET', 'referenceGenome', referenceGenome);
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('findCanonicalSequenceUsingGET', 'entrezGeneId', entrezGeneId);
      const localVarPath = `/api/find-canonical-sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (sequenceType !== undefined) {
        localVarQueryParameter['sequenceType'] = sequenceType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary findCanonicalSequences
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {Array<number>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequencesUsingPOST: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      sequenceType?: 'CDNA' | 'PROTEIN',
      requestBody?: Array<number>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findCanonicalSequencesUsingPOST', 'referenceGenome', referenceGenome);
      const localVarPath = `/api/find-canonical-sequences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (sequenceType !== undefined) {
        localVarQueryParameter['sequenceType'] = sequenceType;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SequenceControllerApi - functional programming interface
 * @export
 */
export const SequenceControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SequenceControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary findCanonicalSequence
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findCanonicalSequenceUsingGET(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'CDNA' | 'PROTEIN',
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sequence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findCanonicalSequenceUsingGET(
        referenceGenome,
        entrezGeneId,
        sequenceType,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary findCanonicalSequences
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {Array<number>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findCanonicalSequencesUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      sequenceType?: 'CDNA' | 'PROTEIN',
      requestBody?: Array<number>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sequence>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findCanonicalSequencesUsingPOST(
        referenceGenome,
        sequenceType,
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SequenceControllerApi - factory interface
 * @export
 */
export const SequenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SequenceControllerApiFp(configuration);
  return {
    /**
     *
     * @summary findCanonicalSequence
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {number} entrezGeneId entrezGeneId
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequenceUsingGET(
      referenceGenome: 'GRCh37' | 'GRCh38',
      entrezGeneId: number,
      sequenceType?: 'CDNA' | 'PROTEIN',
      options?: any
    ): AxiosPromise<Sequence> {
      return localVarFp
        .findCanonicalSequenceUsingGET(referenceGenome, entrezGeneId, sequenceType, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary findCanonicalSequences
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
     * @param {Array<number>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findCanonicalSequencesUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      sequenceType?: 'CDNA' | 'PROTEIN',
      requestBody?: Array<number>,
      options?: any
    ): AxiosPromise<Array<Sequence>> {
      return localVarFp
        .findCanonicalSequencesUsingPOST(referenceGenome, sequenceType, requestBody, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * SequenceControllerApi - object-oriented interface
 * @export
 * @class SequenceControllerApi
 * @extends {BaseAPI}
 */
export class SequenceControllerApi extends BaseAPI {
  /**
   *
   * @summary findCanonicalSequence
   * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
   * @param {number} entrezGeneId entrezGeneId
   * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceControllerApi
   */
  public findCanonicalSequenceUsingGET(
    referenceGenome: 'GRCh37' | 'GRCh38',
    entrezGeneId: number,
    sequenceType?: 'CDNA' | 'PROTEIN',
    options?: AxiosRequestConfig
  ) {
    return SequenceControllerApiFp(this.configuration)
      .findCanonicalSequenceUsingGET(referenceGenome, entrezGeneId, sequenceType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary findCanonicalSequences
   * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
   * @param {'CDNA' | 'PROTEIN'} [sequenceType] sequenceType
   * @param {Array<number>} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SequenceControllerApi
   */
  public findCanonicalSequencesUsingPOST(
    referenceGenome: 'GRCh37' | 'GRCh38',
    sequenceType?: 'CDNA' | 'PROTEIN',
    requestBody?: Array<number>,
    options?: AxiosRequestConfig
  ) {
    return SequenceControllerApiFp(this.configuration)
      .findCanonicalSequencesUsingPOST(referenceGenome, sequenceType, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TranscriptControllerApi - axios parameter creator
 * @export
 */
export const TranscriptControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary addTranscript
     * @param {number} entrezGeneId entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {string} ensemblTranscriptId ensemblTranscriptId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranscriptUsingPOST: async (
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('addTranscriptUsingPOST', 'entrezGeneId', entrezGeneId);
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('addTranscriptUsingPOST', 'referenceGenome', referenceGenome);
      // verify required parameter 'ensemblTranscriptId' is not null or undefined
      assertParamExists('addTranscriptUsingPOST', 'ensemblTranscriptId', ensemblTranscriptId);
      // verify required parameter 'isCanonical' is not null or undefined
      assertParamExists('addTranscriptUsingPOST', 'isCanonical', isCanonical);
      const localVarPath = `/api/add-transcript`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (ensemblTranscriptId !== undefined) {
        localVarQueryParameter['ensemblTranscriptId'] = ensemblTranscriptId;
      }

      if (isCanonical !== undefined) {
        localVarQueryParameter['isCanonical'] = isCanonical;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary compareTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {TranscriptComparisonVM} [transcriptComparisonVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareTranscriptUsingPOST: async (
      hugoSymbol: string,
      transcriptComparisonVM?: TranscriptComparisonVM,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('compareTranscriptUsingPOST', 'hugoSymbol', hugoSymbol);
      const localVarPath = `/api/compare-transcript/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transcriptComparisonVM, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary findTranscriptsByEnsemblIds
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTranscriptsByEnsemblIdsUsingPOST: async (
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'referenceGenome' is not null or undefined
      assertParamExists('findTranscriptsByEnsemblIdsUsingPOST', 'referenceGenome', referenceGenome);
      const localVarPath = `/api/find-transcripts-by-ensembl-ids`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary matchTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {MatchTranscriptVM} [matchTranscriptVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchTranscriptUsingPOST: async (
      hugoSymbol: string,
      matchTranscriptVM?: MatchTranscriptVM,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('matchTranscriptUsingPOST', 'hugoSymbol', hugoSymbol);
      const localVarPath = `/api/match-transcript/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(matchTranscriptVM, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary suggestVariant
     * @param {string} hugoSymbol hugoSymbol
     * @param {number} proteinPosition proteinPosition
     * @param {string} curatedResidue curatedResidue
     * @param {string} grch37Transcript grch37Transcript
     * @param {string} grch38Transcript grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestVariantUsingGET: async (
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('suggestVariantUsingGET', 'hugoSymbol', hugoSymbol);
      // verify required parameter 'proteinPosition' is not null or undefined
      assertParamExists('suggestVariantUsingGET', 'proteinPosition', proteinPosition);
      // verify required parameter 'curatedResidue' is not null or undefined
      assertParamExists('suggestVariantUsingGET', 'curatedResidue', curatedResidue);
      // verify required parameter 'grch37Transcript' is not null or undefined
      assertParamExists('suggestVariantUsingGET', 'grch37Transcript', grch37Transcript);
      // verify required parameter 'grch38Transcript' is not null or undefined
      assertParamExists('suggestVariantUsingGET', 'grch38Transcript', grch38Transcript);
      const localVarPath = `/api/suggest-variant/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (proteinPosition !== undefined) {
        localVarQueryParameter['proteinPosition'] = proteinPosition;
      }

      if (curatedResidue !== undefined) {
        localVarQueryParameter['curatedResidue'] = curatedResidue;
      }

      if (grch37Transcript !== undefined) {
        localVarQueryParameter['grch37Transcript'] = grch37Transcript;
      }

      if (grch38Transcript !== undefined) {
        localVarQueryParameter['grch38Transcript'] = grch38Transcript;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranscriptControllerApi - functional programming interface
 * @export
 */
export const TranscriptControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TranscriptControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary addTranscript
     * @param {number} entrezGeneId entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {string} ensemblTranscriptId ensemblTranscriptId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTranscriptUsingPOST(
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTranscriptUsingPOST(
        entrezGeneId,
        referenceGenome,
        ensemblTranscriptId,
        isCanonical,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary compareTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {TranscriptComparisonVM} [transcriptComparisonVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async compareTranscriptUsingPOST(
      hugoSymbol: string,
      transcriptComparisonVM?: TranscriptComparisonVM,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptComparisonResultVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.compareTranscriptUsingPOST(hugoSymbol, transcriptComparisonVM, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary findTranscriptsByEnsemblIds
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTranscriptsByEnsemblIdsUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TranscriptDTO>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.findTranscriptsByEnsemblIdsUsingPOST(referenceGenome, requestBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary matchTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {MatchTranscriptVM} [matchTranscriptVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async matchTranscriptUsingPOST(
      hugoSymbol: string,
      matchTranscriptVM?: MatchTranscriptVM,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptMatchResultVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.matchTranscriptUsingPOST(hugoSymbol, matchTranscriptVM, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary suggestVariant
     * @param {string} hugoSymbol hugoSymbol
     * @param {number} proteinPosition proteinPosition
     * @param {string} curatedResidue curatedResidue
     * @param {string} grch37Transcript grch37Transcript
     * @param {string} grch38Transcript grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async suggestVariantUsingGET(
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllReferenceTranscriptSuggestionVM>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.suggestVariantUsingGET(
        hugoSymbol,
        proteinPosition,
        curatedResidue,
        grch37Transcript,
        grch38Transcript,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * TranscriptControllerApi - factory interface
 * @export
 */
export const TranscriptControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TranscriptControllerApiFp(configuration);
  return {
    /**
     *
     * @summary addTranscript
     * @param {number} entrezGeneId entrezGeneId
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {string} ensemblTranscriptId ensemblTranscriptId
     * @param {boolean} isCanonical isCanonical
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTranscriptUsingPOST(
      entrezGeneId: number,
      referenceGenome: 'GRCh37' | 'GRCh38',
      ensemblTranscriptId: string,
      isCanonical: boolean,
      options?: any
    ): AxiosPromise<TranscriptDTO> {
      return localVarFp
        .addTranscriptUsingPOST(entrezGeneId, referenceGenome, ensemblTranscriptId, isCanonical, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary compareTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {TranscriptComparisonVM} [transcriptComparisonVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareTranscriptUsingPOST(
      hugoSymbol: string,
      transcriptComparisonVM?: TranscriptComparisonVM,
      options?: any
    ): AxiosPromise<TranscriptComparisonResultVM> {
      return localVarFp.compareTranscriptUsingPOST(hugoSymbol, transcriptComparisonVM, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary findTranscriptsByEnsemblIds
     * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTranscriptsByEnsemblIdsUsingPOST(
      referenceGenome: 'GRCh37' | 'GRCh38',
      requestBody?: Array<string>,
      options?: any
    ): AxiosPromise<Array<TranscriptDTO>> {
      return localVarFp
        .findTranscriptsByEnsemblIdsUsingPOST(referenceGenome, requestBody, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary matchTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {MatchTranscriptVM} [matchTranscriptVM]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchTranscriptUsingPOST(
      hugoSymbol: string,
      matchTranscriptVM?: MatchTranscriptVM,
      options?: any
    ): AxiosPromise<TranscriptMatchResultVM> {
      return localVarFp.matchTranscriptUsingPOST(hugoSymbol, matchTranscriptVM, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary suggestVariant
     * @param {string} hugoSymbol hugoSymbol
     * @param {number} proteinPosition proteinPosition
     * @param {string} curatedResidue curatedResidue
     * @param {string} grch37Transcript grch37Transcript
     * @param {string} grch38Transcript grch38Transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suggestVariantUsingGET(
      hugoSymbol: string,
      proteinPosition: number,
      curatedResidue: string,
      grch37Transcript: string,
      grch38Transcript: string,
      options?: any
    ): AxiosPromise<AllReferenceTranscriptSuggestionVM> {
      return localVarFp
        .suggestVariantUsingGET(hugoSymbol, proteinPosition, curatedResidue, grch37Transcript, grch38Transcript, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * TranscriptControllerApi - object-oriented interface
 * @export
 * @class TranscriptControllerApi
 * @extends {BaseAPI}
 */
export class TranscriptControllerApi extends BaseAPI {
  /**
   *
   * @summary addTranscript
   * @param {number} entrezGeneId entrezGeneId
   * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
   * @param {string} ensemblTranscriptId ensemblTranscriptId
   * @param {boolean} isCanonical isCanonical
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public addTranscriptUsingPOST(
    entrezGeneId: number,
    referenceGenome: 'GRCh37' | 'GRCh38',
    ensemblTranscriptId: string,
    isCanonical: boolean,
    options?: AxiosRequestConfig
  ) {
    return TranscriptControllerApiFp(this.configuration)
      .addTranscriptUsingPOST(entrezGeneId, referenceGenome, ensemblTranscriptId, isCanonical, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary compareTranscript
   * @param {string} hugoSymbol hugoSymbol
   * @param {TranscriptComparisonVM} [transcriptComparisonVM]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public compareTranscriptUsingPOST(hugoSymbol: string, transcriptComparisonVM?: TranscriptComparisonVM, options?: AxiosRequestConfig) {
    return TranscriptControllerApiFp(this.configuration)
      .compareTranscriptUsingPOST(hugoSymbol, transcriptComparisonVM, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary findTranscriptsByEnsemblIds
   * @param {'GRCh37' | 'GRCh38'} referenceGenome referenceGenome
   * @param {Array<string>} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public findTranscriptsByEnsemblIdsUsingPOST(
    referenceGenome: 'GRCh37' | 'GRCh38',
    requestBody?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return TranscriptControllerApiFp(this.configuration)
      .findTranscriptsByEnsemblIdsUsingPOST(referenceGenome, requestBody, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary matchTranscript
   * @param {string} hugoSymbol hugoSymbol
   * @param {MatchTranscriptVM} [matchTranscriptVM]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public matchTranscriptUsingPOST(hugoSymbol: string, matchTranscriptVM?: MatchTranscriptVM, options?: AxiosRequestConfig) {
    return TranscriptControllerApiFp(this.configuration)
      .matchTranscriptUsingPOST(hugoSymbol, matchTranscriptVM, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary suggestVariant
   * @param {string} hugoSymbol hugoSymbol
   * @param {number} proteinPosition proteinPosition
   * @param {string} curatedResidue curatedResidue
   * @param {string} grch37Transcript grch37Transcript
   * @param {string} grch38Transcript grch38Transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptControllerApi
   */
  public suggestVariantUsingGET(
    hugoSymbol: string,
    proteinPosition: number,
    curatedResidue: string,
    grch37Transcript: string,
    grch38Transcript: string,
    options?: AxiosRequestConfig
  ) {
    return TranscriptControllerApiFp(this.configuration)
      .suggestVariantUsingGET(hugoSymbol, proteinPosition, curatedResidue, grch37Transcript, grch38Transcript, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserResourceApi - axios parameter creator
 * @export
 */
export const UserResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary getAllUsers
     * @param {number} [page] Page number of the requested page
     * @param {number} [size] Size of a page
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsingGET: async (
      page?: number,
      size?: number,
      sort?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (sort) {
        localVarQueryParameter['sort'] = sort;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary getUser
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUsingGET: async (login: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'login' is not null or undefined
      assertParamExists('getUserUsingGET', 'login', login);
      const localVarPath = `/api/admin/users/{login}`.replace(`{${'login'}}`, encodeURIComponent(String(login)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Authorization required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserResourceApi - functional programming interface
 * @export
 */
export const UserResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary getAllUsers
     * @param {number} [page] Page number of the requested page
     * @param {number} [size] Size of a page
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsersUsingGET(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsersUsingGET(page, size, sort, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary getUser
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUsingGET(
      login: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUsingGET(login, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserResourceApi - factory interface
 * @export
 */
export const UserResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserResourceApiFp(configuration);
  return {
    /**
     *
     * @summary getAllUsers
     * @param {number} [page] Page number of the requested page
     * @param {number} [size] Size of a page
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsingGET(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<UserDTO>> {
      return localVarFp.getAllUsersUsingGET(page, size, sort, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary getUser
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUsingGET(login: string, options?: any): AxiosPromise<UserDTO> {
      return localVarFp.getUserUsingGET(login, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserResourceApi - object-oriented interface
 * @export
 * @class UserResourceApi
 * @extends {BaseAPI}
 */
export class UserResourceApi extends BaseAPI {
  /**
   *
   * @summary getAllUsers
   * @param {number} [page] Page number of the requested page
   * @param {number} [size] Size of a page
   * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public getAllUsersUsingGET(page?: number, size?: number, sort?: Array<string>, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .getAllUsersUsingGET(page, size, sort, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary getUser
   * @param {string} login login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public getUserUsingGET(login: string, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .getUserUsingGET(login, options)
      .then(request => request(this.axios, this.basePath));
  }
}
