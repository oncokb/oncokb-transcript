/* tslint:disable */
/* eslint-disable */
/**
 * OncoKB APIs
 * OncoKB, a comprehensive and curated precision oncology knowledge base, offers oncologists detailed, evidence-based information about individual somatic mutations and structural alterations present in patient tumors with the goal of supporting optimal treatment decisions.
 *
 * The version of the OpenAPI document: v1.5.0
 * Contact: contact@oncokb.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Alteration
 */
export interface Alteration {
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  alteration?: string;
  /**
   *
   * @type {VariantConsequence}
   * @memberof Alteration
   */
  consequence?: VariantConsequence;
  /**
   *
   * @type {Gene}
   * @memberof Alteration
   */
  gene?: Gene;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof Alteration
   */
  proteinEnd?: number;
  /**
   *
   * @type {number}
   * @memberof Alteration
   */
  proteinStart?: number;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  refResidues?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Alteration
   */
  referenceGenomes?: Array<AlterationReferenceGenomesEnum>;
  /**
   *
   * @type {string}
   * @memberof Alteration
   */
  variantResidues?: string;
}

export const AlterationReferenceGenomesEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type AlterationReferenceGenomesEnum = (typeof AlterationReferenceGenomesEnum)[keyof typeof AlterationReferenceGenomesEnum];

/**
 *
 * @export
 * @interface AnnotateMutationByGenomicChangeQuery
 */
export interface AnnotateMutationByGenomicChangeQuery {
  /**
   *
   * @type {Array<string>}
   * @memberof AnnotateMutationByGenomicChangeQuery
   */
  evidenceTypes?: Array<AnnotateMutationByGenomicChangeQueryEvidenceTypesEnum>;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByGenomicChangeQuery
   */
  genomicLocation?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByGenomicChangeQuery
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByGenomicChangeQuery
   */
  referenceGenome?: AnnotateMutationByGenomicChangeQueryReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByGenomicChangeQuery
   */
  tumorType?: string;
}

export const AnnotateMutationByGenomicChangeQueryEvidenceTypesEnum = {
  GeneSummary: 'GENE_SUMMARY',
  MutationSummary: 'MUTATION_SUMMARY',
  TumorTypeSummary: 'TUMOR_TYPE_SUMMARY',
  GeneTumorTypeSummary: 'GENE_TUMOR_TYPE_SUMMARY',
  PrognosticSummary: 'PROGNOSTIC_SUMMARY',
  DiagnosticSummary: 'DIAGNOSTIC_SUMMARY',
  GeneBackground: 'GENE_BACKGROUND',
  Oncogenic: 'ONCOGENIC',
  MutationEffect: 'MUTATION_EFFECT',
  Vus: 'VUS',
  PrognosticImplication: 'PROGNOSTIC_IMPLICATION',
  DiagnosticImplication: 'DIAGNOSTIC_IMPLICATION',
  StandardTherapeuticImplicationsForDrugSensitivity: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_SENSITIVITY',
  StandardTherapeuticImplicationsForDrugResistance: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_RESISTANCE',
  InvestigationalTherapeuticImplicationsDrugSensitivity: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_SENSITIVITY',
  InvestigationalTherapeuticImplicationsDrugResistance: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_RESISTANCE',
} as const;

export type AnnotateMutationByGenomicChangeQueryEvidenceTypesEnum =
  (typeof AnnotateMutationByGenomicChangeQueryEvidenceTypesEnum)[keyof typeof AnnotateMutationByGenomicChangeQueryEvidenceTypesEnum];
export const AnnotateMutationByGenomicChangeQueryReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type AnnotateMutationByGenomicChangeQueryReferenceGenomeEnum =
  (typeof AnnotateMutationByGenomicChangeQueryReferenceGenomeEnum)[keyof typeof AnnotateMutationByGenomicChangeQueryReferenceGenomeEnum];

/**
 *
 * @export
 * @interface AnnotateMutationByHGVSgQuery
 */
export interface AnnotateMutationByHGVSgQuery {
  /**
   *
   * @type {Array<string>}
   * @memberof AnnotateMutationByHGVSgQuery
   */
  evidenceTypes?: Array<AnnotateMutationByHGVSgQueryEvidenceTypesEnum>;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByHGVSgQuery
   */
  hgvsg?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByHGVSgQuery
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByHGVSgQuery
   */
  referenceGenome?: AnnotateMutationByHGVSgQueryReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof AnnotateMutationByHGVSgQuery
   */
  tumorType?: string;
}

export const AnnotateMutationByHGVSgQueryEvidenceTypesEnum = {
  GeneSummary: 'GENE_SUMMARY',
  MutationSummary: 'MUTATION_SUMMARY',
  TumorTypeSummary: 'TUMOR_TYPE_SUMMARY',
  GeneTumorTypeSummary: 'GENE_TUMOR_TYPE_SUMMARY',
  PrognosticSummary: 'PROGNOSTIC_SUMMARY',
  DiagnosticSummary: 'DIAGNOSTIC_SUMMARY',
  GeneBackground: 'GENE_BACKGROUND',
  Oncogenic: 'ONCOGENIC',
  MutationEffect: 'MUTATION_EFFECT',
  Vus: 'VUS',
  PrognosticImplication: 'PROGNOSTIC_IMPLICATION',
  DiagnosticImplication: 'DIAGNOSTIC_IMPLICATION',
  StandardTherapeuticImplicationsForDrugSensitivity: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_SENSITIVITY',
  StandardTherapeuticImplicationsForDrugResistance: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_RESISTANCE',
  InvestigationalTherapeuticImplicationsDrugSensitivity: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_SENSITIVITY',
  InvestigationalTherapeuticImplicationsDrugResistance: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_RESISTANCE',
} as const;

export type AnnotateMutationByHGVSgQueryEvidenceTypesEnum =
  (typeof AnnotateMutationByHGVSgQueryEvidenceTypesEnum)[keyof typeof AnnotateMutationByHGVSgQueryEvidenceTypesEnum];
export const AnnotateMutationByHGVSgQueryReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type AnnotateMutationByHGVSgQueryReferenceGenomeEnum =
  (typeof AnnotateMutationByHGVSgQueryReferenceGenomeEnum)[keyof typeof AnnotateMutationByHGVSgQueryReferenceGenomeEnum];

/**
 *
 * @export
 * @interface AnnotatedVariant
 */
export interface AnnotatedVariant {
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof AnnotatedVariant
   */
  entrezGeneId?: number;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  gene?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  grch37Isoform?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  grch37RefSeq?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  grch38Isoform?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  grch38RefSeq?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  mutationEffect?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  mutationEffectAbstracts?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  mutationEffectPmids?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  oncogenicity?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  proteinChange?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  referenceGenome?: string;
  /**
   *
   * @type {string}
   * @memberof AnnotatedVariant
   */
  variant?: string;
}
/**
 *
 * @export
 * @interface ApiHttpError
 */
export interface ApiHttpError {
  /**
   *
   * @type {string}
   * @memberof ApiHttpError
   */
  detail?: string;
  /**
   *
   * @type {string}
   * @memberof ApiHttpError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof ApiHttpError
   */
  path?: string;
  /**
   *
   * @type {number}
   * @memberof ApiHttpError
   */
  status?: number;
  /**
   *
   * @type {string}
   * @memberof ApiHttpError
   */
  title?: string;
}
/**
 *
 * @export
 * @interface Article
 */
export interface Article {
  /**
   *
   * @type {string}
   * @memberof Article
   */
  abstract?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  authors?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  elocationId?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  issue?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  journal?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pages?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pmid?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  pubDate?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  reference?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Article
   */
  volume?: string;
}
/**
 *
 * @export
 * @interface ArticleAbstract
 */
export interface ArticleAbstract {
  /**
   *
   * @type {string}
   * @memberof ArticleAbstract
   */
  abstract?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleAbstract
   */
  link?: string;
}
/**
 *
 * @export
 * @interface BiologicalVariant
 */
export interface BiologicalVariant {
  /**
   *
   * @type {string}
   * @memberof BiologicalVariant
   */
  mutationEffect?: string;
  /**
   *
   * @type {Array<ArticleAbstract>}
   * @memberof BiologicalVariant
   */
  mutationEffectAbstracts?: Array<ArticleAbstract>;
  /**
   *
   * @type {string}
   * @memberof BiologicalVariant
   */
  mutationEffectDescription?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BiologicalVariant
   */
  mutationEffectPmids?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BiologicalVariant
   */
  oncogenic?: string;
  /**
   *
   * @type {Array<ArticleAbstract>}
   * @memberof BiologicalVariant
   */
  oncogenicAbstracts?: Array<ArticleAbstract>;
  /**
   *
   * @type {Array<string>}
   * @memberof BiologicalVariant
   */
  oncogenicPmids?: Array<string>;
  /**
   *
   * @type {Alteration}
   * @memberof BiologicalVariant
   */
  variant?: Alteration;
}
/**
 *
 * @export
 * @interface CancerTypeCount
 */
export interface CancerTypeCount {
  /**
   *
   * @type {string}
   * @memberof CancerTypeCount
   */
  cancerType?: string;
  /**
   *
   * @type {number}
   * @memberof CancerTypeCount
   */
  count?: number;
}
/**
 *
 * @export
 * @interface Citations
 */
export interface Citations {
  /**
   * Set of Abstract sources
   * @type {Array<ArticleAbstract>}
   * @memberof Citations
   */
  abstracts?: Array<ArticleAbstract>;
  /**
   * Set of PubMed article ids
   * @type {Array<string>}
   * @memberof Citations
   */
  pmids?: Array<string>;
}
/**
 *
 * @export
 * @interface ClinicalVariant
 */
export interface ClinicalVariant {
  /**
   *
   * @type {Array<TumorType>}
   * @memberof ClinicalVariant
   */
  cancerTypes?: Array<TumorType>;
  /**
   *
   * @type {Array<string>}
   * @memberof ClinicalVariant
   */
  drug?: Array<string>;
  /**
   *
   * @type {Array<ArticleAbstract>}
   * @memberof ClinicalVariant
   */
  drugAbstracts?: Array<ArticleAbstract>;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  drugDescription?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ClinicalVariant
   */
  drugPmids?: Array<string>;
  /**
   *
   * @type {Array<TumorType>}
   * @memberof ClinicalVariant
   */
  excludedCancerTypes?: Array<TumorType>;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  fdaLevel?: string;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  level?: string;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  liquidPropagationLevel?: string;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  oncogenic?: string;
  /**
   *
   * @type {string}
   * @memberof ClinicalVariant
   */
  solidPropagationLevel?: string;
  /**
   *
   * @type {Alteration}
   * @memberof ClinicalVariant
   */
  variant?: Alteration;
}
/**
 *
 * @export
 * @interface CplAnnotationRequest
 */
export interface CplAnnotationRequest {
  /**
   *
   * @type {string}
   * @memberof CplAnnotationRequest
   */
  alteration?: string;
  /**
   *
   * @type {string}
   * @memberof CplAnnotationRequest
   */
  cancerType?: string;
  /**
   *
   * @type {string}
   * @memberof CplAnnotationRequest
   */
  hugoSymbol?: string;
  /**
   *
   * @type {string}
   * @memberof CplAnnotationRequest
   */
  referenceGenome?: CplAnnotationRequestReferenceGenomeEnum;
  /**
   *
   * @type {string}
   * @memberof CplAnnotationRequest
   */
  template?: string;
}

export const CplAnnotationRequestReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type CplAnnotationRequestReferenceGenomeEnum =
  (typeof CplAnnotationRequestReferenceGenomeEnum)[keyof typeof CplAnnotationRequestReferenceGenomeEnum];

/**
 *
 * @export
 * @interface DownloadAvailability
 */
export interface DownloadAvailability {
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasAllActionableVariants?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasAllAnnotatedVariants?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasAllCuratedGenes?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasCancerGeneList?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasReadme?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DownloadAvailability
   */
  hasSqlDump?: boolean;
  /**
   *
   * @type {string}
   * @memberof DownloadAvailability
   */
  version?: string;
}
/**
 *
 * @export
 * @interface Drug
 */
export interface Drug {
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  drugName?: string;
  /**
   *
   * @type {string}
   * @memberof Drug
   */
  ncitCode?: string;
}
/**
 *
 * @export
 * @interface DrugSynonym
 */
export interface DrugSynonym {
  /**
   *
   * @type {Drug}
   * @memberof DrugSynonym
   */
  drug?: Drug;
  /**
   *
   * @type {number}
   * @memberof DrugSynonym
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof DrugSynonym
   */
  name?: string;
}
/**
 *
 * @export
 * @interface EnsemblGene
 */
export interface EnsemblGene {
  /**
   *
   * @type {boolean}
   * @memberof EnsemblGene
   */
  canonical?: boolean;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  chromosome?: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  end?: number;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  ensemblGeneId?: string;
  /**
   *
   * @type {string}
   * @memberof EnsemblGene
   */
  referenceGenome?: string;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  start?: number;
  /**
   *
   * @type {number}
   * @memberof EnsemblGene
   */
  strand?: number;
}
/**
 *
 * @export
 * @interface EnsemblTranscript
 */
export interface EnsemblTranscript {
  /**
   * Consensus CDS (CCDS) ID
   * @type {string}
   * @memberof EnsemblTranscript
   */
  ccdsId?: string;
  /**
   * Exon information
   * @type {Array<Exon>}
   * @memberof EnsemblTranscript
   */
  exons?: Array<Exon>;
  /**
   * Ensembl gene id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  geneId: string;
  /**
   * Hugo symbols
   * @type {Array<string>}
   * @memberof EnsemblTranscript
   */
  hugoSymbols?: Array<string>;
  /**
   * Pfam domains
   * @type {Array<PfamDomainRange>}
   * @memberof EnsemblTranscript
   */
  pfamDomains?: Array<PfamDomainRange>;
  /**
   * Ensembl protein id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  proteinId: string;
  /**
   * Length of protein
   * @type {number}
   * @memberof EnsemblTranscript
   */
  proteinLength?: number;
  /**
   * RefSeq mRNA ID
   * @type {string}
   * @memberof EnsemblTranscript
   */
  refseqMrnaId?: string;
  /**
   * Ensembl transcript id
   * @type {string}
   * @memberof EnsemblTranscript
   */
  transcriptId: string;
  /**
   *
   * @type {string}
   * @memberof EnsemblTranscript
   */
  uniprotId?: string;
  /**
   * UTR information
   * @type {Array<UntranslatedRegion>}
   * @memberof EnsemblTranscript
   */
  utrs?: Array<UntranslatedRegion>;
}
/**
 *
 * @export
 * @interface Evidence
 */
export interface Evidence {
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  additionalInfo?: string;
  /**
   *
   * @type {Array<Alteration>}
   * @memberof Evidence
   */
  alterations?: Array<Alteration>;
  /**
   *
   * @type {Array<Article>}
   * @memberof Evidence
   */
  articles?: Array<Article>;
  /**
   *
   * @type {Array<TumorType>}
   * @memberof Evidence
   */
  cancerTypes?: Array<TumorType>;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  evidenceType?: EvidenceEvidenceTypeEnum;
  /**
   *
   * @type {Array<TumorType>}
   * @memberof Evidence
   */
  excludedCancerTypes?: Array<TumorType>;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  fdaLevel?: EvidenceFdaLevelEnum;
  /**
   *
   * @type {Gene}
   * @memberof Evidence
   */
  gene?: Gene;
  /**
   *
   * @type {number}
   * @memberof Evidence
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  knownEffect?: string;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  lastEdit?: string;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  lastReview?: string;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  levelOfEvidence?: EvidenceLevelOfEvidenceEnum;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  liquidPropagationLevel?: EvidenceLiquidPropagationLevelEnum;
  /**
   *
   * @type {Array<TumorType>}
   * @memberof Evidence
   */
  relevantCancerTypes?: Array<TumorType>;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  solidPropagationLevel?: EvidenceSolidPropagationLevelEnum;
  /**
   *
   * @type {Array<Treatment>}
   * @memberof Evidence
   */
  treatments?: Array<Treatment>;
  /**
   *
   * @type {string}
   * @memberof Evidence
   */
  uuid?: string;
}

export const EvidenceEvidenceTypeEnum = {
  GeneSummary: 'GENE_SUMMARY',
  MutationSummary: 'MUTATION_SUMMARY',
  TumorTypeSummary: 'TUMOR_TYPE_SUMMARY',
  GeneTumorTypeSummary: 'GENE_TUMOR_TYPE_SUMMARY',
  PrognosticSummary: 'PROGNOSTIC_SUMMARY',
  DiagnosticSummary: 'DIAGNOSTIC_SUMMARY',
  GeneBackground: 'GENE_BACKGROUND',
  Oncogenic: 'ONCOGENIC',
  MutationEffect: 'MUTATION_EFFECT',
  Vus: 'VUS',
  PrognosticImplication: 'PROGNOSTIC_IMPLICATION',
  DiagnosticImplication: 'DIAGNOSTIC_IMPLICATION',
  StandardTherapeuticImplicationsForDrugSensitivity: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_SENSITIVITY',
  StandardTherapeuticImplicationsForDrugResistance: 'STANDARD_THERAPEUTIC_IMPLICATIONS_FOR_DRUG_RESISTANCE',
  InvestigationalTherapeuticImplicationsDrugSensitivity: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_SENSITIVITY',
  InvestigationalTherapeuticImplicationsDrugResistance: 'INVESTIGATIONAL_THERAPEUTIC_IMPLICATIONS_DRUG_RESISTANCE',
} as const;

export type EvidenceEvidenceTypeEnum = (typeof EvidenceEvidenceTypeEnum)[keyof typeof EvidenceEvidenceTypeEnum];
export const EvidenceFdaLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type EvidenceFdaLevelEnum = (typeof EvidenceFdaLevelEnum)[keyof typeof EvidenceFdaLevelEnum];
export const EvidenceLevelOfEvidenceEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type EvidenceLevelOfEvidenceEnum = (typeof EvidenceLevelOfEvidenceEnum)[keyof typeof EvidenceLevelOfEvidenceEnum];
export const EvidenceLiquidPropagationLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type EvidenceLiquidPropagationLevelEnum =
  (typeof EvidenceLiquidPropagationLevelEnum)[keyof typeof EvidenceLiquidPropagationLevelEnum];
export const EvidenceSolidPropagationLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type EvidenceSolidPropagationLevelEnum = (typeof EvidenceSolidPropagationLevelEnum)[keyof typeof EvidenceSolidPropagationLevelEnum];

/**
 *
 * @export
 * @interface Exon
 */
export interface Exon {
  /**
   * End position of exon
   * @type {number}
   * @memberof Exon
   */
  exonEnd: number;
  /**
   * Exon id
   * @type {string}
   * @memberof Exon
   */
  exonId: string;
  /**
   * Start position of exon
   * @type {number}
   * @memberof Exon
   */
  exonStart: number;
  /**
   * Number of exon in transcript
   * @type {number}
   * @memberof Exon
   */
  rank: number;
  /**
   * Strand exon is on, -1 for - and 1 for +
   * @type {number}
   * @memberof Exon
   */
  strand: number;
  /**
   * Exon version
   * @type {number}
   * @memberof Exon
   */
  version: number;
}
/**
 *
 * @export
 * @interface Gene
 */
export interface Gene {
  /**
   *
   * @type {number}
   * @memberof Gene
   */
  entrezGeneId?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Gene
   */
  geneAliases?: Array<string>;
  /**
   *
   * @type {Array<Geneset>}
   * @memberof Gene
   */
  genesets?: Array<Geneset>;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  grch37Isoform?: string;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  grch37RefSeq?: string;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  grch38Isoform?: string;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  grch38RefSeq?: string;
  /**
   *
   * @type {string}
   * @memberof Gene
   */
  hugoSymbol?: string;
  /**
   *
   * @type {boolean}
   * @memberof Gene
   */
  oncogene?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Gene
   */
  tsg?: boolean;
}
/**
 *
 * @export
 * @interface GeneNumber
 */
export interface GeneNumber {
  /**
   *
   * @type {number}
   * @memberof GeneNumber
   */
  alteration?: number;
  /**
   *
   * @type {Gene}
   * @memberof GeneNumber
   */
  gene?: Gene;
  /**
   *
   * @type {string}
   * @memberof GeneNumber
   */
  highestDiagnosticImplicationLevel?: string;
  /**
   *
   * @type {string}
   * @memberof GeneNumber
   */
  highestFdaLevel?: string;
  /**
   *
   * @type {string}
   * @memberof GeneNumber
   */
  highestPrognosticImplicationLevel?: string;
  /**
   *
   * @type {string}
   * @memberof GeneNumber
   */
  highestResistanceLevel?: string;
  /**
   *
   * @type {string}
   * @memberof GeneNumber
   */
  highestSensitiveLevel?: string;
  /**
   *
   * @type {number}
   * @memberof GeneNumber
   */
  tumorType?: number;
}
/**
 *
 * @export
 * @interface Geneset
 */
export interface Geneset {
  /**
   *
   * @type {Array<Gene>}
   * @memberof Geneset
   */
  genes?: Array<Gene>;
  /**
   *
   * @type {number}
   * @memberof Geneset
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Geneset
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Geneset
   */
  uuid?: string;
}
/**
 *
 * @export
 * @interface GenomeNexusAnnotatedVariantInfo
 */
export interface GenomeNexusAnnotatedVariantInfo {
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  consequenceTerms?: string;
  /**
   *
   * @type {number}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  entrezGeneId?: number;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  genomicLocation?: string;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  hgvsg?: string;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  hgvspShort?: string;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  hugoSymbol?: string;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  originalVariantQuery?: string;
  /**
   *
   * @type {number}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  proteinEnd?: number;
  /**
   *
   * @type {number}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  proteinStart?: number;
  /**
   *
   * @type {string}
   * @memberof GenomeNexusAnnotatedVariantInfo
   */
  referenceGenome?: GenomeNexusAnnotatedVariantInfoReferenceGenomeEnum;
}

export const GenomeNexusAnnotatedVariantInfoReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type GenomeNexusAnnotatedVariantInfoReferenceGenomeEnum =
  (typeof GenomeNexusAnnotatedVariantInfoReferenceGenomeEnum)[keyof typeof GenomeNexusAnnotatedVariantInfoReferenceGenomeEnum];

/**
 *
 * @export
 * @interface Implication
 */
export interface Implication {
  /**
   * List of abstracts cited to support the level of evidence. Defaulted to empty list
   * @type {Array<ArticleAbstract>}
   * @memberof Implication
   */
  abstracts?: Array<ArticleAbstract>;
  /**
   * List of alterations associated with implication
   * @type {Array<string>}
   * @memberof Implication
   */
  alterations?: Array<string>;
  /**
   * DEPRECATED
   * @type {string}
   * @memberof Implication
   */
  description?: string;
  /**
   * Level associated with implication
   * @type {string}
   * @memberof Implication
   */
  levelOfEvidence?: ImplicationLevelOfEvidenceEnum;
  /**
   * List of PubMed IDs cited to support the level of evidence. Defaulted to empty list
   * @type {Array<string>}
   * @memberof Implication
   */
  pmids?: Array<string>;
  /**
   *
   * @type {TumorType}
   * @memberof Implication
   */
  tumorType?: TumorType;
}

export const ImplicationLevelOfEvidenceEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type ImplicationLevelOfEvidenceEnum = (typeof ImplicationLevelOfEvidenceEnum)[keyof typeof ImplicationLevelOfEvidenceEnum];

/**
 *
 * @export
 * @interface IndicatorQueryTreatment
 */
export interface IndicatorQueryTreatment {
  /**
   * List of abstracts cited in the treatment description. Defaulted to empty list
   * @type {Array<ArticleAbstract>}
   * @memberof IndicatorQueryTreatment
   */
  abstracts?: Array<ArticleAbstract>;
  /**
   * List of alterations associated with therapeutic implication
   * @type {Array<string>}
   * @memberof IndicatorQueryTreatment
   */
  alterations?: Array<string>;
  /**
   * DEPRECATED
   * @type {Array<string>}
   * @memberof IndicatorQueryTreatment
   */
  approvedIndications?: Array<string>;
  /**
   * Treatment description. Defaulted to \"\"
   * @type {string}
   * @memberof IndicatorQueryTreatment
   */
  description?: string;
  /**
   * List of drugs associated with therapeutic implication
   * @type {Array<Drug>}
   * @memberof IndicatorQueryTreatment
   */
  drugs?: Array<Drug>;
  /**
   * FDA level associated with implication
   * @type {string}
   * @memberof IndicatorQueryTreatment
   */
  fdaLevel?: IndicatorQueryTreatmentFdaLevelEnum;
  /**
   * Therapeutic level associated with implication
   * @type {string}
   * @memberof IndicatorQueryTreatment
   */
  level?: IndicatorQueryTreatmentLevelEnum;
  /**
   *
   * @type {TumorType}
   * @memberof IndicatorQueryTreatment
   */
  levelAssociatedCancerType?: TumorType;
  /**
   * Excluded cancer types. Defaulted to empty list
   * @type {Array<TumorType>}
   * @memberof IndicatorQueryTreatment
   */
  levelExcludedCancerTypes?: Array<TumorType>;
  /**
   * List of PubMed IDs cited in the treatment description. Defaulted to empty list
   * @type {Array<string>}
   * @memberof IndicatorQueryTreatment
   */
  pmids?: Array<string>;
}

export const IndicatorQueryTreatmentFdaLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type IndicatorQueryTreatmentFdaLevelEnum =
  (typeof IndicatorQueryTreatmentFdaLevelEnum)[keyof typeof IndicatorQueryTreatmentFdaLevelEnum];
export const IndicatorQueryTreatmentLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type IndicatorQueryTreatmentLevelEnum = (typeof IndicatorQueryTreatmentLevelEnum)[keyof typeof IndicatorQueryTreatmentLevelEnum];

/**
 *
 * @export
 * @interface LevelNumber
 */
export interface LevelNumber {
  /**
   *
   * @type {Array<Gene>}
   * @memberof LevelNumber
   */
  genes?: Array<Gene>;
  /**
   *
   * @type {string}
   * @memberof LevelNumber
   */
  level?: LevelNumberLevelEnum;
}

export const LevelNumberLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type LevelNumberLevelEnum = (typeof LevelNumberLevelEnum)[keyof typeof LevelNumberLevelEnum];

/**
 *
 * @export
 * @interface MainNumber
 */
export interface MainNumber {
  /**
   *
   * @type {number}
   * @memberof MainNumber
   */
  alteration?: number;
  /**
   *
   * @type {number}
   * @memberof MainNumber
   */
  drug?: number;
  /**
   *
   * @type {number}
   * @memberof MainNumber
   */
  gene?: number;
  /**
   *
   * @type {Array<MainNumberLevel>}
   * @memberof MainNumber
   */
  level?: Array<MainNumberLevel>;
  /**
   *
   * @type {number}
   * @memberof MainNumber
   */
  tumorType?: number;
}
/**
 *
 * @export
 * @interface MainNumberLevel
 */
export interface MainNumberLevel {
  /**
   *
   * @type {string}
   * @memberof MainNumberLevel
   */
  level?: string;
  /**
   *
   * @type {number}
   * @memberof MainNumberLevel
   */
  number?: number;
}
/**
 * OncoTree Cancer Type
 * @export
 * @interface MainType
 */
export interface MainType {
  /**
   *
   * @type {number}
   * @memberof MainType
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MainType
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MainType
   */
  tumorForm?: MainTypeTumorFormEnum;
}

export const MainTypeTumorFormEnum = {
  Solid: 'SOLID',
  Liquid: 'LIQUID',
  Mixed: 'MIXED',
} as const;

export type MainTypeTumorFormEnum = (typeof MainTypeTumorFormEnum)[keyof typeof MainTypeTumorFormEnum];

/**
 *
 * @export
 * @interface MatchVariant
 */
export interface MatchVariant {
  /**
   *
   * @type {string}
   * @memberof MatchVariant
   */
  alteration?: string;
  /**
   *
   * @type {string}
   * @memberof MatchVariant
   */
  hugoSymbol?: string;
}
/**
 *
 * @export
 * @interface MatchVariantRequest
 */
export interface MatchVariantRequest {
  /**
   *
   * @type {Array<MatchVariant>}
   * @memberof MatchVariantRequest
   */
  oncokbVariants?: Array<MatchVariant>;
  /**
   *
   * @type {Array<Query>}
   * @memberof MatchVariantRequest
   */
  queries?: Array<Query>;
}
/**
 *
 * @export
 * @interface MatchVariantResult
 */
export interface MatchVariantResult {
  /**
   *
   * @type {Query}
   * @memberof MatchVariantResult
   */
  query?: Query;
  /**
   *
   * @type {Array<MatchVariant>}
   * @memberof MatchVariantResult
   */
  result?: Array<MatchVariant>;
}
/**
 *
 * @export
 * @interface MutationEffectResp
 */
export interface MutationEffectResp {
  /**
   *
   * @type {Citations}
   * @memberof MutationEffectResp
   */
  citations?: Citations;
  /**
   * A brief overview of the biological and oncogenic effect of the variant. Defaulted to \"\"
   * @type {string}
   * @memberof MutationEffectResp
   */
  description?: string;
  /**
   * Indicates the effect of the mutation on the gene. Defaulted to \"\"
   * @type {string}
   * @memberof MutationEffectResp
   */
  knownEffect?: MutationEffectRespKnownEffectEnum;
}

export const MutationEffectRespKnownEffectEnum = {
  GainOfFunction: 'Gain-of-function',
  Inconclusive: 'Inconclusive',
  LossOfFunction: 'Loss-of-function',
  LikelyLossOfFunction: 'Likely Loss-of-function',
  LikelyGainOfFunction: 'Likely Gain-of-function',
  Neutral: 'Neutral',
  Unknown: 'Unknown',
  LikelySwitchOfFunction: 'Likely Switch-of-function',
  SwitchOfFunction: 'Switch-of-function',
  LikelyNeutral: 'Likely Neutral',
} as const;

export type MutationEffectRespKnownEffectEnum = (typeof MutationEffectRespKnownEffectEnum)[keyof typeof MutationEffectRespKnownEffectEnum];

/**
 *
 * @export
 * @interface PfamDomainRange
 */
export interface PfamDomainRange {
  /**
   * Pfam domain end amino acid
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainEnd: number;
  /**
   * Pfam domain id
   * @type {string}
   * @memberof PfamDomainRange
   */
  pfamDomainId: string;
  /**
   * Pfam domain start amino acid
   * @type {number}
   * @memberof PfamDomainRange
   */
  pfamDomainStart: number;
}
/**
 *
 * @export
 * @interface PortalAlteration
 */
export interface PortalAlteration {
  /**
   *
   * @type {string}
   * @memberof PortalAlteration
   */
  alterationType?: string;
  /**
   *
   * @type {string}
   * @memberof PortalAlteration
   */
  cancerStudy?: string;
  /**
   *
   * @type {string}
   * @memberof PortalAlteration
   */
  cancerType?: string;
  /**
   *
   * @type {Gene}
   * @memberof PortalAlteration
   */
  gene?: Gene;
  /**
   *
   * @type {string}
   * @memberof PortalAlteration
   */
  proteinChange?: string;
  /**
   *
   * @type {number}
   * @memberof PortalAlteration
   */
  proteinEndPosition?: number;
  /**
   *
   * @type {number}
   * @memberof PortalAlteration
   */
  proteinStartPosition?: number;
  /**
   *
   * @type {string}
   * @memberof PortalAlteration
   */
  sampleId?: string;
}
/**
 * Enriched user annotation query
 * @export
 * @interface Query
 */
export interface Query {
  /**
   * (Nullable) Alteration from original query or the resolved alteration from HGVS variant
   * @type {string}
   * @memberof Query
   */
  alteration?: string;
  /**
   * (Nullable) Alteration type
   * @type {string}
   * @memberof Query
   */
  alterationType?: QueryAlterationTypeEnum;
  /**
   * (Nullable) The OncoKB canonical transcript. See https://www.oncokb.org/cancer-genes
   * @type {string}
   * @memberof Query
   */
  canonicalTranscript?: string;
  /**
   * (Nullable) Variant consequence term from Ensembl. See https://useast.ensembl.org/info/genome/variation/prediction/predicted_data.html
   * @type {string}
   * @memberof Query
   */
  consequence?: string;
  /**
   * (Nullable) Unique gene identifiers from NCBI. May be null if omitted from original query, otherwise filled in by OncoKB
   * @type {number}
   * @memberof Query
   */
  entrezGeneId?: number;
  /**
   * (Nullable) The hgvsg or genomic location from original query
   * @type {string}
   * @memberof Query
   */
  hgvs?: string;
  /**
   * (Nullable) Additional message for \"hgvs\" field. May indicate reason for failed hgvs annotation.
   * @type {string}
   * @memberof Query
   */
  hgvsInfo?: string;
  /**
   * (Nullable) The gene symbol used in Human Genome Organisation
   * @type {string}
   * @memberof Query
   */
  hugoSymbol?: string;
  /**
   * (Nullable) The id passed in request for the user to distinguish the query.
   * @type {string}
   * @memberof Query
   */
  id?: string;
  /**
   * (Nullable) Protein end position
   * @type {number}
   * @memberof Query
   */
  proteinEnd?: number;
  /**
   * (Nullable) Protein start position
   * @type {number}
   * @memberof Query
   */
  proteinStart?: number;
  /**
   * Reference genome build version. Defaulted to GRCh37
   * @type {string}
   * @memberof Query
   */
  referenceGenome?: QueryReferenceGenomeEnum;
  /**
   * (Nullable) Structural variant type
   * @type {string}
   * @memberof Query
   */
  svType?: QuerySvTypeEnum;
  /**
   * (Nullable) Oncotree tumor type name, code, or main type.
   * @type {string}
   * @memberof Query
   */
  tumorType?: string;
}

export const QueryAlterationTypeEnum = {
  Mutation: 'MUTATION',
  CopyNumberAlteration: 'COPY_NUMBER_ALTERATION',
  StructuralVariant: 'STRUCTURAL_VARIANT',
} as const;

export type QueryAlterationTypeEnum = (typeof QueryAlterationTypeEnum)[keyof typeof QueryAlterationTypeEnum];
export const QueryReferenceGenomeEnum = {
  Grch37: 'GRCh37',
  Grch38: 'GRCh38',
} as const;

export type QueryReferenceGenomeEnum = (typeof QueryReferenceGenomeEnum)[keyof typeof QueryReferenceGenomeEnum];
export const QuerySvTypeEnum = {
  Deletion: 'DELETION',
  Translocation: 'TRANSLOCATION',
  Duplication: 'DUPLICATION',
  Insertion: 'INSERTION',
  Inversion: 'INVERSION',
  Fusion: 'FUSION',
  Unknown: 'UNKNOWN',
} as const;

export type QuerySvTypeEnum = (typeof QuerySvTypeEnum)[keyof typeof QuerySvTypeEnum];

/**
 *
 * @export
 * @interface RelevantCancerTypeQuery
 */
export interface RelevantCancerTypeQuery {
  /**
   *
   * @type {string}
   * @memberof RelevantCancerTypeQuery
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof RelevantCancerTypeQuery
   */
  mainType?: string;
}
/**
 *
 * @export
 * @interface TranscriptCoverageFilterResult
 */
export interface TranscriptCoverageFilterResult {
  /**
   *
   * @type {boolean}
   * @memberof TranscriptCoverageFilterResult
   */
  isCovered?: boolean;
  /**
   *
   * @type {string}
   * @memberof TranscriptCoverageFilterResult
   */
  variant?: string;
}
/**
 *
 * @export
 * @interface TranscriptResult
 */
export interface TranscriptResult {
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptResult
   */
  grch37Transcript?: EnsemblTranscript;
  /**
   *
   * @type {EnsemblTranscript}
   * @memberof TranscriptResult
   */
  grch38Transcript?: EnsemblTranscript;
  /**
   *
   * @type {string}
   * @memberof TranscriptResult
   */
  note?: string;
}
/**
 *
 * @export
 * @interface Treatment
 */
export interface Treatment {
  /**
   *
   * @type {Array<string>}
   * @memberof Treatment
   */
  approvedIndications?: Array<string>;
  /**
   *
   * @type {Array<TreatmentDrug>}
   * @memberof Treatment
   */
  drugs?: Array<TreatmentDrug>;
  /**
   *
   * @type {number}
   * @memberof Treatment
   */
  priority?: number;
}
/**
 *
 * @export
 * @interface TreatmentDrug
 */
export interface TreatmentDrug {
  /**
   *
   * @type {number}
   * @memberof TreatmentDrug
   */
  priority?: number;
  /**
   *
   * @type {TreatmentDrugId}
   * @memberof TreatmentDrug
   */
  treatmentDrugId?: TreatmentDrugId;
}
/**
 *
 * @export
 * @interface TreatmentDrugId
 */
export interface TreatmentDrugId {
  /**
   *
   * @type {Drug}
   * @memberof TreatmentDrugId
   */
  drug?: Drug;
}
/**
 * OncoTree Detailed Cancer Type
 * @export
 * @interface TumorType
 */
export interface TumorType {
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  color?: string;
  /**
   *
   * @type {number}
   * @memberof TumorType
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof TumorType
   */
  level?: number;
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  mainType?: string;
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  subtype?: string;
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  tissue?: string;
  /**
   *
   * @type {string}
   * @memberof TumorType
   */
  tumorForm?: TumorTypeTumorFormEnum;
}

export const TumorTypeTumorFormEnum = {
  Solid: 'SOLID',
  Liquid: 'LIQUID',
  Mixed: 'MIXED',
} as const;

export type TumorTypeTumorFormEnum = (typeof TumorTypeTumorFormEnum)[keyof typeof TumorTypeTumorFormEnum];

/**
 *
 * @export
 * @interface TypeaheadSearchResp
 */
export interface TypeaheadSearchResp {
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  annotation?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof TypeaheadSearchResp
   */
  annotationByLevel?: { [key: string]: string };
  /**
   *
   * @type {Drug}
   * @memberof TypeaheadSearchResp
   */
  drug?: Drug;
  /**
   *
   * @type {Gene}
   * @memberof TypeaheadSearchResp
   */
  gene?: Gene;
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  highestResistanceLevel?: string;
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  highestSensitiveLevel?: string;
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  oncogenicity?: string;
  /**
   *
   * @type {string}
   * @memberof TypeaheadSearchResp
   */
  queryType?: TypeaheadSearchRespQueryTypeEnum;
  /**
   *
   * @type {Array<TumorType>}
   * @memberof TypeaheadSearchResp
   */
  tumorTypes?: Array<TumorType>;
  /**
   *
   * @type {boolean}
   * @memberof TypeaheadSearchResp
   */
  variantExist?: boolean;
  /**
   *
   * @type {Array<Alteration>}
   * @memberof TypeaheadSearchResp
   */
  variants?: Array<Alteration>;
  /**
   *
   * @type {boolean}
   * @memberof TypeaheadSearchResp
   */
  vus?: boolean;
}

export const TypeaheadSearchRespQueryTypeEnum = {
  Gene: 'GENE',
  Variant: 'VARIANT',
  Drug: 'DRUG',
  Text: 'TEXT',
  Genomic: 'GENOMIC',
  CancerType: 'CANCER_TYPE',
} as const;

export type TypeaheadSearchRespQueryTypeEnum = (typeof TypeaheadSearchRespQueryTypeEnum)[keyof typeof TypeaheadSearchRespQueryTypeEnum];

/**
 *
 * @export
 * @interface UntranslatedRegion
 */
export interface UntranslatedRegion {
  /**
   * End position of UTR
   * @type {number}
   * @memberof UntranslatedRegion
   */
  end: number;
  /**
   * Start position of UTR
   * @type {number}
   * @memberof UntranslatedRegion
   */
  start: number;
  /**
   * Strand UTR is on, -1 for - and 1 for +
   * @type {number}
   * @memberof UntranslatedRegion
   */
  strand: number;
  /**
   * UTR Type
   * @type {string}
   * @memberof UntranslatedRegion
   */
  type: string;
}
/**
 *
 * @export
 * @interface VariantAnnotation
 */
export interface VariantAnnotation {
  /**
   * Indicates whether the alternate allele has been curated. See SOP Protocol 9.1
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  alleleExist?: boolean;
  /**
   *
   * @type {string}
   * @memberof VariantAnnotation
   */
  background?: string;
  /**
   * OncoKB data version. See www.oncokb.org/news
   * @type {string}
   * @memberof VariantAnnotation
   */
  dataVersion?: string;
  /**
   * List of diagnostic implications. Defaulted to empty list
   * @type {Array<Implication>}
   * @memberof VariantAnnotation
   */
  diagnosticImplications?: Array<Implication>;
  /**
   * Diagnostic summary. Defaulted to \"\"
   * @type {string}
   * @memberof VariantAnnotation
   */
  diagnosticSummary?: string;
  /**
   * Indicates whether the gene is curated by OncoKB
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  geneExist?: boolean;
  /**
   * Gene summary. Defaulted to \"\"
   * @type {string}
   * @memberof VariantAnnotation
   */
  geneSummary?: string;
  /**
   * (Nullable) The highest diagnostic level from a list of diagnostic evidences.
   * @type {string}
   * @memberof VariantAnnotation
   */
  highestDiagnosticImplicationLevel?: VariantAnnotationHighestDiagnosticImplicationLevelEnum;
  /**
   * (Nullable) The highest FDA level from a list of therapeutic evidences.
   * @type {string}
   * @memberof VariantAnnotation
   */
  highestFdaLevel?: VariantAnnotationHighestFdaLevelEnum;
  /**
   * (Nullable) The highest prognostic level from a list of prognostic evidences.
   * @type {string}
   * @memberof VariantAnnotation
   */
  highestPrognosticImplicationLevel?: VariantAnnotationHighestPrognosticImplicationLevelEnum;
  /**
   * (Nullable) The highest resistance level from a list of therapeutic evidences.
   * @type {string}
   * @memberof VariantAnnotation
   */
  highestResistanceLevel?: VariantAnnotationHighestResistanceLevelEnum;
  /**
   * (Nullable) The highest sensitivity level from a list of therapeutic evidences.
   * @type {string}
   * @memberof VariantAnnotation
   */
  highestSensitiveLevel?: VariantAnnotationHighestSensitiveLevelEnum;
  /**
   * Whether variant is recurrently found in cancer with statistical significance, as defined in Chang et al. (2017). See SOP Protocol 9.2
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  hotspot?: boolean;
  /**
   * OncoKB data release date. Formatted as MM/DD/YYYY
   * @type {string}
   * @memberof VariantAnnotation
   */
  lastUpdate?: string;
  /**
   *
   * @type {MutationEffectResp}
   * @memberof VariantAnnotation
   */
  mutationEffect?: MutationEffectResp;
  /**
   * The oncogenicity status of the variant. Defaulted to \"Unknown\".
   * @type {string}
   * @memberof VariantAnnotation
   */
  oncogenic?: VariantAnnotationOncogenicEnum;
  /**
   * DEPRECATED
   * @type {Array<string>}
   * @memberof VariantAnnotation
   */
  otherSignificantResistanceLevels?: Array<VariantAnnotationOtherSignificantResistanceLevelsEnum>;
  /**
   * DEPRECATED
   * @type {Array<string>}
   * @memberof VariantAnnotation
   */
  otherSignificantSensitiveLevels?: Array<VariantAnnotationOtherSignificantSensitiveLevelsEnum>;
  /**
   * List of prognostic implications. Defaulted to empty list
   * @type {Array<Implication>}
   * @memberof VariantAnnotation
   */
  prognosticImplications?: Array<Implication>;
  /**
   * Prognostic summary. Defaulted to \"\"
   * @type {string}
   * @memberof VariantAnnotation
   */
  prognosticSummary?: string;
  /**
   *
   * @type {Query}
   * @memberof VariantAnnotation
   */
  query?: Query;
  /**
   * List of therapeutic implications implications. Defaulted to empty list
   * @type {Array<IndicatorQueryTreatment>}
   * @memberof VariantAnnotation
   */
  treatments?: Array<IndicatorQueryTreatment>;
  /**
   * Tumor type summary. Defaulted to \"\"
   * @type {string}
   * @memberof VariantAnnotation
   */
  tumorTypeSummary?: string;
  /**
   *
   * @type {Array<VariantAnnotationTumorType>}
   * @memberof VariantAnnotation
   */
  tumorTypes?: Array<VariantAnnotationTumorType>;
  /**
   * Indicates whether an exact match for the queried variant is curated
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  variantExist?: boolean;
  /**
   * Variant summary. Defaulted to \"\"
   * @type {string}
   * @memberof VariantAnnotation
   */
  variantSummary?: string;
  /**
   *
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  vue?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof VariantAnnotation
   */
  vus?: boolean;
}

export const VariantAnnotationHighestDiagnosticImplicationLevelEnum = {
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3.',
} as const;

export type VariantAnnotationHighestDiagnosticImplicationLevelEnum =
  (typeof VariantAnnotationHighestDiagnosticImplicationLevelEnum)[keyof typeof VariantAnnotationHighestDiagnosticImplicationLevelEnum];
export const VariantAnnotationHighestFdaLevelEnum = {
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
} as const;

export type VariantAnnotationHighestFdaLevelEnum =
  (typeof VariantAnnotationHighestFdaLevelEnum)[keyof typeof VariantAnnotationHighestFdaLevelEnum];
export const VariantAnnotationHighestPrognosticImplicationLevelEnum = {
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
} as const;

export type VariantAnnotationHighestPrognosticImplicationLevelEnum =
  (typeof VariantAnnotationHighestPrognosticImplicationLevelEnum)[keyof typeof VariantAnnotationHighestPrognosticImplicationLevelEnum];
export const VariantAnnotationHighestResistanceLevelEnum = {
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
} as const;

export type VariantAnnotationHighestResistanceLevelEnum =
  (typeof VariantAnnotationHighestResistanceLevelEnum)[keyof typeof VariantAnnotationHighestResistanceLevelEnum];
export const VariantAnnotationHighestSensitiveLevelEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
} as const;

export type VariantAnnotationHighestSensitiveLevelEnum =
  (typeof VariantAnnotationHighestSensitiveLevelEnum)[keyof typeof VariantAnnotationHighestSensitiveLevelEnum];
export const VariantAnnotationOncogenicEnum = {
  Oncogenic: 'Oncogenic',
  LikelyOncogenic: 'Likely Oncogenic',
  LikelyNeutral: 'Likely Neutral',
  Inconclusive: 'Inconclusive',
  Resistance: 'Resistance',
  Unknown: 'Unknown',
} as const;

export type VariantAnnotationOncogenicEnum = (typeof VariantAnnotationOncogenicEnum)[keyof typeof VariantAnnotationOncogenicEnum];
export const VariantAnnotationOtherSignificantResistanceLevelsEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type VariantAnnotationOtherSignificantResistanceLevelsEnum =
  (typeof VariantAnnotationOtherSignificantResistanceLevelsEnum)[keyof typeof VariantAnnotationOtherSignificantResistanceLevelsEnum];
export const VariantAnnotationOtherSignificantSensitiveLevelsEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;

export type VariantAnnotationOtherSignificantSensitiveLevelsEnum =
  (typeof VariantAnnotationOtherSignificantSensitiveLevelsEnum)[keyof typeof VariantAnnotationOtherSignificantSensitiveLevelsEnum];

/**
 *
 * @export
 * @interface VariantAnnotationTumorType
 */
export interface VariantAnnotationTumorType {
  /**
   *
   * @type {Array<Evidence>}
   * @memberof VariantAnnotationTumorType
   */
  evidences?: Array<Evidence>;
  /**
   *
   * @type {boolean}
   * @memberof VariantAnnotationTumorType
   */
  relevantTumorType?: boolean;
  /**
   *
   * @type {TumorType}
   * @memberof VariantAnnotationTumorType
   */
  tumorType?: TumorType;
}
/**
 *
 * @export
 * @interface VariantConsequence
 */
export interface VariantConsequence {
  /**
   *
   * @type {string}
   * @memberof VariantConsequence
   */
  description?: string;
  /**
   *
   * @type {boolean}
   * @memberof VariantConsequence
   */
  isGenerallyTruncating?: boolean;
  /**
   *
   * @type {string}
   * @memberof VariantConsequence
   */
  term?: string;
}

/**
 * DrugsApi - axios parameter creator
 * @export
 */
export const DrugsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugGetUsingGET: async (query: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchDrugGetUsingGET', 'query', query);
      const localVarPath = `/search/ncitDrugs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DrugsApi - functional programming interface
 * @export
 */
export const DrugsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DrugsApiAxiosParamCreator(configuration);
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDrugGetUsingGET(
      query: string,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchDrugGetUsingGET(query, limit, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['DrugsApi.searchDrugGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DrugsApi - factory interface
 * @export
 */
export const DrugsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DrugsApiFp(configuration);
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Drug>> {
      return localVarFp.searchDrugGetUsingGET(query, limit, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DrugsApi - object-oriented interface
 * @export
 * @class DrugsApi
 * @extends {BaseAPI}
 */
export class DrugsApi extends BaseAPI {
  /**
   * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
   * @summary searchDrugGet
   * @param {string} query The search query, it could be drug name, NCIT code
   * @param {number} [limit] The limit of returned result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DrugsApi
   */
  public searchDrugGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig) {
    return DrugsApiFp(this.configuration)
      .searchDrugGetUsingGET(query, limit, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugGetUsingGET: async (query: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchDrugGetUsingGET', 'query', query);
      const localVarPath = `/search/ncitDrugs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search to find treatments.
     * @summary searchTreatmentsGet
     * @param {string} gene The search query, it could be hugoSymbol or entrezGeneId.
     * @param {string} [level] The level of evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTreatmentsGetUsingGET: async (gene: string, level?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'gene' is not null or undefined
      assertParamExists('searchTreatmentsGetUsingGET', 'gene', gene);
      const localVarPath = `/search/treatments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (gene !== undefined) {
        localVarQueryParameter['gene'] = gene;
      }

      if (level !== undefined) {
        localVarQueryParameter['level'] = level;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Find matches based on blur query.
     * @summary searchTypeAheadGet
     * @param {string} query The search query, it could be hugoSymbol, entrezGeneId, variant, or cancer type. At least two characters. Maximum two keywords are supported, separated by space
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTypeAheadGetUsingGET: async (query: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      assertParamExists('searchTypeAheadGetUsingGET', 'query', query);
      const localVarPath = `/search/typeahead`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (query !== undefined) {
        localVarQueryParameter['query'] = query;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get annotated variants information for specified gene.
     * @summary searchVariantsBiologicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchVariantsBiologicalGetUsingGET: async (hugoSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/search/variants/biological`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of variant clinical information for specified gene.
     * @summary searchVariantsClinicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchVariantsClinicalGetUsingGET: async (hugoSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/search/variants/clinical`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration);
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchDrugGetUsingGET(
      query: string,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Drug>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchDrugGetUsingGET(query, limit, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['SearchApi.searchDrugGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Search to find treatments.
     * @summary searchTreatmentsGet
     * @param {string} gene The search query, it could be hugoSymbol or entrezGeneId.
     * @param {string} [level] The level of evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchTreatmentsGetUsingGET(
      gene: string,
      level?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Treatment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchTreatmentsGetUsingGET(gene, level, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SearchApi.searchTreatmentsGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Find matches based on blur query.
     * @summary searchTypeAheadGet
     * @param {string} query The search query, it could be hugoSymbol, entrezGeneId, variant, or cancer type. At least two characters. Maximum two keywords are supported, separated by space
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchTypeAheadGetUsingGET(
      query: string,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TypeaheadSearchResp>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchTypeAheadGetUsingGET(query, limit, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SearchApi.searchTypeAheadGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get annotated variants information for specified gene.
     * @summary searchVariantsBiologicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchVariantsBiologicalGetUsingGET(
      hugoSymbol?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BiologicalVariant>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchVariantsBiologicalGetUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SearchApi.searchVariantsBiologicalGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get list of variant clinical information for specified gene.
     * @summary searchVariantsClinicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchVariantsClinicalGetUsingGET(
      hugoSymbol?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClinicalVariant>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchVariantsClinicalGetUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['SearchApi.searchVariantsClinicalGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SearchApiFp(configuration);
  return {
    /**
     * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
     * @summary searchDrugGet
     * @param {string} query The search query, it could be drug name, NCIT code
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchDrugGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Drug>> {
      return localVarFp.searchDrugGetUsingGET(query, limit, options).then(request => request(axios, basePath));
    },
    /**
     * Search to find treatments.
     * @summary searchTreatmentsGet
     * @param {string} gene The search query, it could be hugoSymbol or entrezGeneId.
     * @param {string} [level] The level of evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTreatmentsGetUsingGET(gene: string, level?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Treatment>> {
      return localVarFp.searchTreatmentsGetUsingGET(gene, level, options).then(request => request(axios, basePath));
    },
    /**
     * Find matches based on blur query.
     * @summary searchTypeAheadGet
     * @param {string} query The search query, it could be hugoSymbol, entrezGeneId, variant, or cancer type. At least two characters. Maximum two keywords are supported, separated by space
     * @param {number} [limit] The limit of returned result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTypeAheadGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TypeaheadSearchResp>> {
      return localVarFp.searchTypeAheadGetUsingGET(query, limit, options).then(request => request(axios, basePath));
    },
    /**
     * Get annotated variants information for specified gene.
     * @summary searchVariantsBiologicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchVariantsBiologicalGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BiologicalVariant>> {
      return localVarFp.searchVariantsBiologicalGetUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
    /**
     * Get list of variant clinical information for specified gene.
     * @summary searchVariantsClinicalGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchVariantsClinicalGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClinicalVariant>> {
      return localVarFp.searchVariantsClinicalGetUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
  /**
   * Find NCIT matches based on blur query. This is not for search OncoKB curated drugs. Please use drugs/lookup for that purpose.
   * @summary searchDrugGet
   * @param {string} query The search query, it could be drug name, NCIT code
   * @param {number} [limit] The limit of returned result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchDrugGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .searchDrugGetUsingGET(query, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Search to find treatments.
   * @summary searchTreatmentsGet
   * @param {string} gene The search query, it could be hugoSymbol or entrezGeneId.
   * @param {string} [level] The level of evidence.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchTreatmentsGetUsingGET(gene: string, level?: string, options?: RawAxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .searchTreatmentsGetUsingGET(gene, level, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Find matches based on blur query.
   * @summary searchTypeAheadGet
   * @param {string} query The search query, it could be hugoSymbol, entrezGeneId, variant, or cancer type. At least two characters. Maximum two keywords are supported, separated by space
   * @param {number} [limit] The limit of returned result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchTypeAheadGetUsingGET(query: string, limit?: number, options?: RawAxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .searchTypeAheadGetUsingGET(query, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get annotated variants information for specified gene.
   * @summary searchVariantsBiologicalGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchVariantsBiologicalGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .searchVariantsBiologicalGetUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get list of variant clinical information for specified gene.
   * @summary searchVariantsClinicalGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchVariantsClinicalGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig) {
    return SearchApiFp(this.configuration)
      .searchVariantsClinicalGetUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TranscriptApi - axios parameter creator
 * @export
 */
export const TranscriptApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * cache Genome Nexus variant info
     * @summary cacheGenomeNexusVariantInfoPost
     * @param {Array<GenomeNexusAnnotatedVariantInfo>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cacheGenomeNexusVariantInfoPostUsingPOST: async (
      body: Array<GenomeNexusAnnotatedVariantInfo>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('cacheGenomeNexusVariantInfoPostUsingPOST', 'body', body);
      const localVarPath = `/cacheGnVariantInfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch Genome Nexus variant info by genomic change
     * @summary fetchGenomeNexusVariantInfoByGenomicChangePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST: async (
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST', 'body', body);
      const localVarPath = `/fetchGnVariants/byGenomicChange`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch Genome Nexus variant info by HGVSg
     * @summary fetchGenomeNexusVariantInfoByHGVSgPost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST: async (
      body: Array<AnnotateMutationByHGVSgQuery>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST', 'body', body);
      const localVarPath = `/fetchGnVariants/byHGVSg`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get transcript info in both GRCh37 and 38.
     * @summary getTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranscriptUsingGET: async (hugoSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('getTranscriptUsingGET', 'hugoSymbol', hugoSymbol);
      const localVarPath = `/transcripts/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TranscriptApi - functional programming interface
 * @export
 */
export const TranscriptApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TranscriptApiAxiosParamCreator(configuration);
  return {
    /**
     * cache Genome Nexus variant info
     * @summary cacheGenomeNexusVariantInfoPost
     * @param {Array<GenomeNexusAnnotatedVariantInfo>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cacheGenomeNexusVariantInfoPostUsingPOST(
      body: Array<GenomeNexusAnnotatedVariantInfo>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cacheGenomeNexusVariantInfoPostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TranscriptApi.cacheGenomeNexusVariantInfoPostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch Genome Nexus variant info by genomic change
     * @summary fetchGenomeNexusVariantInfoByGenomicChangePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenomeNexusAnnotatedVariantInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TranscriptApi.fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Fetch Genome Nexus variant info by HGVSg
     * @summary fetchGenomeNexusVariantInfoByHGVSgPost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(
      body: Array<AnnotateMutationByHGVSgQuery>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenomeNexusAnnotatedVariantInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TranscriptApi.fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get transcript info in both GRCh37 and 38.
     * @summary getTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTranscriptUsingGET(
      hugoSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptResult>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscriptUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TranscriptApi.getTranscriptUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TranscriptApi - factory interface
 * @export
 */
export const TranscriptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TranscriptApiFp(configuration);
  return {
    /**
     * cache Genome Nexus variant info
     * @summary cacheGenomeNexusVariantInfoPost
     * @param {Array<GenomeNexusAnnotatedVariantInfo>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cacheGenomeNexusVariantInfoPostUsingPOST(
      body: Array<GenomeNexusAnnotatedVariantInfo>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp.cacheGenomeNexusVariantInfoPostUsingPOST(body, options).then(request => request(axios, basePath));
    },
    /**
     * Fetch Genome Nexus variant info by genomic change
     * @summary fetchGenomeNexusVariantInfoByGenomicChangePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GenomeNexusAnnotatedVariantInfo>> {
      return localVarFp.fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(body, options).then(request => request(axios, basePath));
    },
    /**
     * Fetch Genome Nexus variant info by HGVSg
     * @summary fetchGenomeNexusVariantInfoByHGVSgPost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(
      body: Array<AnnotateMutationByHGVSgQuery>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GenomeNexusAnnotatedVariantInfo>> {
      return localVarFp.fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(body, options).then(request => request(axios, basePath));
    },
    /**
     * Get transcript info in both GRCh37 and 38.
     * @summary getTranscript
     * @param {string} hugoSymbol hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTranscriptUsingGET(hugoSymbol: string, options?: RawAxiosRequestConfig): AxiosPromise<TranscriptResult> {
      return localVarFp.getTranscriptUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * TranscriptApi - object-oriented interface
 * @export
 * @class TranscriptApi
 * @extends {BaseAPI}
 */
export class TranscriptApi extends BaseAPI {
  /**
   * cache Genome Nexus variant info
   * @summary cacheGenomeNexusVariantInfoPost
   * @param {Array<GenomeNexusAnnotatedVariantInfo>} body List of queries. Please see swagger.json for request body format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptApi
   */
  public cacheGenomeNexusVariantInfoPostUsingPOST(body: Array<GenomeNexusAnnotatedVariantInfo>, options?: RawAxiosRequestConfig) {
    return TranscriptApiFp(this.configuration)
      .cacheGenomeNexusVariantInfoPostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Fetch Genome Nexus variant info by genomic change
   * @summary fetchGenomeNexusVariantInfoByGenomicChangePost
   * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries. Please see swagger.json for request body format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptApi
   */
  public fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(
    body: Array<AnnotateMutationByGenomicChangeQuery>,
    options?: RawAxiosRequestConfig,
  ) {
    return TranscriptApiFp(this.configuration)
      .fetchGenomeNexusVariantInfoByGenomicChangePostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Fetch Genome Nexus variant info by HGVSg
   * @summary fetchGenomeNexusVariantInfoByHGVSgPost
   * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries. Please see swagger.json for request body format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptApi
   */
  public fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(body: Array<AnnotateMutationByHGVSgQuery>, options?: RawAxiosRequestConfig) {
    return TranscriptApiFp(this.configuration)
      .fetchGenomeNexusVariantInfoByHGVSgPostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get transcript info in both GRCh37 and 38.
   * @summary getTranscript
   * @param {string} hugoSymbol hugoSymbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TranscriptApi
   */
  public getTranscriptUsingGET(hugoSymbol: string, options?: RawAxiosRequestConfig) {
    return TranscriptApiFp(this.configuration)
      .getTranscriptUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UtilsApi - axios parameter creator
 * @export
 */
export const UtilsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Annotate a string using CPL
     * @summary utilAnnotateCPL
     * @param {CplAnnotationRequest} cplRequest CPL Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilAnnotateCPLUsingPOST: async (cplRequest: CplAnnotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'cplRequest' is not null or undefined
      assertParamExists('utilAnnotateCPLUsingPOST', 'cplRequest', cplRequest);
      const localVarPath = `/utils/annotateCPL`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cplRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about what files are available by data version
     * @summary utilDataAvailabilityGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataAvailabilityGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/data/availability`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get readme info for specific data release version
     * @summary utilDataReadmeGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataReadmeGetUsingGET: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/data/readme`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (version !== undefined) {
        localVarQueryParameter['version'] = version;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilDataSqlDumpGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataSqlDumpGetUsingGET: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/data/sqlDump`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (version !== undefined) {
        localVarQueryParameter['version'] = version;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilDataTranscriptSqlDump
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataTranscriptSqlDumpUsingGET: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/data/transcriptSqlDump`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (version !== undefined) {
        localVarQueryParameter['version'] = version;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Filter genomic change based on oncokb coverage
     * @summary utilFilterGenomicChangeBasedOnCoveragePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilFilterGenomicChangeBasedOnCoveragePostUsingPOST: async (
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('utilFilterGenomicChangeBasedOnCoveragePostUsingPOST', 'body', body);
      const localVarPath = `/utils/filterGenomicChangeBasedOnCoverage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Filter HGVSg based on oncokb coverage
     * @summary utilFilterHgvsgBasedOnCoveragePost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilFilterHgvsgBasedOnCoveragePostUsingPOST: async (
      body: Array<AnnotateMutationByHGVSgQuery>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('utilFilterHgvsgBasedOnCoveragePostUsingPOST', 'body', body);
      const localVarPath = `/utils/filterHgvsgBasedOnCoverage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilMutationMapperDataGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilMutationMapperDataGetUsingGET: async (hugoSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/mutationMapperData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilPortalAlterationSampleCountGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilPortalAlterationSampleCountGetUsingGET: async (hugoSymbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/portalAlterationSampleCount`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the list of relevant alterations
     * @summary utilRelevantAlterationsGet
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {number} [entrezGeneId] alteration
     * @param {string} [alteration] alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantAlterationsGetUsingGET: async (
      referenceGenome?: string,
      entrezGeneId?: number,
      alteration?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/relevantAlterations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (alteration !== undefined) {
        localVarQueryParameter['alteration'] = alteration;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantCancerTypesPost
     * @param {Array<RelevantCancerTypeQuery>} body List of queries.
     * @param {UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum} [levelOfEvidence] Level of Evidence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantCancerTypesPostUsingPOST: async (
      body: Array<RelevantCancerTypeQuery>,
      levelOfEvidence?: UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('utilRelevantCancerTypesPostUsingPOST', 'body', body);
      const localVarPath = `/utils/relevantCancerTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (levelOfEvidence !== undefined) {
        localVarQueryParameter['levelOfEvidence'] = levelOfEvidence;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantTumorTypesGet
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantTumorTypesGetUsingGET: async (tumorType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/relevantTumorTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tumorType !== undefined) {
        localVarQueryParameter['tumorType'] = tumorType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilUpdateTranscriptGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch37RefSeq] grch37RefSeq
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {string} [grch38RefSeq] grch38RefSeq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilUpdateTranscriptGetUsingGET: async (
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch37RefSeq?: string,
      grch38Isoform?: string,
      grch38RefSeq?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/updateTranscript`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (grch37Isoform !== undefined) {
        localVarQueryParameter['grch37Isoform'] = grch37Isoform;
      }

      if (grch37RefSeq !== undefined) {
        localVarQueryParameter['grch37RefSeq'] = grch37RefSeq;
      }

      if (grch38Isoform !== undefined) {
        localVarQueryParameter['grch38Isoform'] = grch38Isoform;
      }

      if (grch38RefSeq !== undefined) {
        localVarQueryParameter['grch38RefSeq'] = grch38RefSeq;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary utilValidateTranscriptUpdateGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilValidateTranscriptUpdateGetUsingGET: async (
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch38Isoform?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/validateTranscriptUpdate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (grch37Isoform !== undefined) {
        localVarQueryParameter['grch37Isoform'] = grch37Isoform;
      }

      if (grch38Isoform !== undefined) {
        localVarQueryParameter['grch38Isoform'] = grch38Isoform;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all the info for the query
     * @summary utilVariantAnnotationGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {string} [alteration] Alteration
     * @param {string} [hgvsg] HGVS genomic format. Example: 7:g.140453136A&gt;T
     * @param {string} [genomicChange] Genomic change format. Example: 7,140453136,140453136,A,T
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilVariantAnnotationGetUsingGET: async (
      hugoSymbol?: string,
      entrezGeneId?: number,
      referenceGenome?: string,
      alteration?: string,
      hgvsg?: string,
      genomicChange?: string,
      tumorType?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/variantAnnotation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      if (referenceGenome !== undefined) {
        localVarQueryParameter['referenceGenome'] = referenceGenome;
      }

      if (alteration !== undefined) {
        localVarQueryParameter['alteration'] = alteration;
      }

      if (hgvsg !== undefined) {
        localVarQueryParameter['hgvsg'] = hgvsg;
      }

      if (genomicChange !== undefined) {
        localVarQueryParameter['genomicChange'] = genomicChange;
      }

      if (tumorType !== undefined) {
        localVarQueryParameter['tumorType'] = tumorType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the list of Ensembl genes.
     * @summary utilsEnsemblGenesGet
     * @param {number} entrezGeneId Gene entrez id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsEnsemblGenesGetUsingGET: async (entrezGeneId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'entrezGeneId' is not null or undefined
      assertParamExists('utilsEnsemblGenesGetUsingGET', 'entrezGeneId', entrezGeneId);
      const localVarPath = `/utils/ensembleGenes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (entrezGeneId !== undefined) {
        localVarQueryParameter['entrezGeneId'] = entrezGeneId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the list of evidences by levels.
     * @summary utilsEvidencesByLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsEvidencesByLevelsGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/evidences/levels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Determine whether variant is hotspot mutation.
     * @summary utilsHotspotMutationGet
     * @param {string} [hugoSymbol] Gene hugo symbol
     * @param {string} [variant] Variant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsHotspotMutationGetUsingGET: async (
      hugoSymbol?: string,
      variant?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/utils/isHotspot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (hugoSymbol !== undefined) {
        localVarQueryParameter['hugoSymbol'] = hugoSymbol;
      }

      if (variant !== undefined) {
        localVarQueryParameter['variant'] = variant;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get gene related numbers
     * @summary utilsNumbersGeneGet
     * @param {string} hugoSymbol The gene symbol used in Human Genome Organisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersGeneGetUsingGET: async (hugoSymbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'hugoSymbol' is not null or undefined
      assertParamExists('utilsNumbersGeneGetUsingGET', 'hugoSymbol', hugoSymbol);
      const localVarPath = `/utils/numbers/gene/{hugoSymbol}`.replace(`{${'hugoSymbol'}}`, encodeURIComponent(String(hugoSymbol)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersGenesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersGenesGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/numbers/genes/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersLevelsGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/numbers/levels/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get numbers served for the main page dashboard.
     * @summary utilsNumbersMainGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersMainGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/numbers/main/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get All Suggested Variants.
     * @summary utilsSuggestedVariantsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsSuggestedVariantsGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/suggestedVariants`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the full list of TumorTypes.
     * @summary utilsTumorTypesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsTumorTypesGetUsingGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/tumorTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check if clinical trials are valid or not by nctId.
     * @summary validateTrials
     * @param {Array<string>} [nctIds] NCTID list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTrialsUsingGET: async (nctIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/validation/trials`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (nctIds) {
        localVarQueryParameter['nctIds'] = nctIds;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check if the genomic example will be mapped to OncoKB variant.
     * @summary validateVariantExampleGet
     * @param {string} [examples] The genomic examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateVariantExampleGetUsingGET: async (examples?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/utils/match/variant`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(examples, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check which OncoKB variants can be mapped on genomic examples.
     * @summary validateVariantExamplePost
     * @param {MatchVariantRequest} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateVariantExamplePostUsingPOST: async (body: MatchVariantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('validateVariantExamplePostUsingPOST', 'body', body);
      const localVarPath = `/utils/match/variant`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UtilsApi - functional programming interface
 * @export
 */
export const UtilsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UtilsApiAxiosParamCreator(configuration);
  return {
    /**
     * Annotate a string using CPL
     * @summary utilAnnotateCPL
     * @param {CplAnnotationRequest} cplRequest CPL Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilAnnotateCPLUsingPOST(
      cplRequest: CplAnnotationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilAnnotateCPLUsingPOST(cplRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['UtilsApi.utilAnnotateCPLUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get information about what files are available by data version
     * @summary utilDataAvailabilityGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilDataAvailabilityGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DownloadAvailability>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilDataAvailabilityGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilDataAvailabilityGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get readme info for specific data release version
     * @summary utilDataReadmeGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilDataReadmeGetUsingGET(
      version?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilDataReadmeGetUsingGET(version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['UtilsApi.utilDataReadmeGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilDataSqlDumpGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilDataSqlDumpGetUsingGET(
      version?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilDataSqlDumpGetUsingGET(version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilDataSqlDumpGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilDataTranscriptSqlDump
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilDataTranscriptSqlDumpUsingGET(
      version?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilDataTranscriptSqlDumpUsingGET(version, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilDataTranscriptSqlDumpUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Filter genomic change based on oncokb coverage
     * @summary utilFilterGenomicChangeBasedOnCoveragePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilFilterGenomicChangeBasedOnCoveragePostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Filter HGVSg based on oncokb coverage
     * @summary utilFilterHgvsgBasedOnCoveragePost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilFilterHgvsgBasedOnCoveragePostUsingPOST(
      body: Array<AnnotateMutationByHGVSgQuery>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilFilterHgvsgBasedOnCoveragePostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilFilterHgvsgBasedOnCoveragePostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilMutationMapperDataGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilMutationMapperDataGetUsingGET(
      hugoSymbol?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortalAlteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilMutationMapperDataGetUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilMutationMapperDataGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilPortalAlterationSampleCountGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilPortalAlterationSampleCountGetUsingGET(
      hugoSymbol?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CancerTypeCount>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilPortalAlterationSampleCountGetUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilPortalAlterationSampleCountGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the list of relevant alterations
     * @summary utilRelevantAlterationsGet
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {number} [entrezGeneId] alteration
     * @param {string} [alteration] alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilRelevantAlterationsGetUsingGET(
      referenceGenome?: string,
      entrezGeneId?: number,
      alteration?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alteration>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilRelevantAlterationsGetUsingGET(
        referenceGenome,
        entrezGeneId,
        alteration,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilRelevantAlterationsGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantCancerTypesPost
     * @param {Array<RelevantCancerTypeQuery>} body List of queries.
     * @param {UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum} [levelOfEvidence] Level of Evidence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilRelevantCancerTypesPostUsingPOST(
      body: Array<RelevantCancerTypeQuery>,
      levelOfEvidence?: UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TumorType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilRelevantCancerTypesPostUsingPOST(body, levelOfEvidence, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilRelevantCancerTypesPostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantTumorTypesGet
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilRelevantTumorTypesGetUsingGET(
      tumorType?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TumorType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilRelevantTumorTypesGetUsingGET(tumorType, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilRelevantTumorTypesGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilUpdateTranscriptGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch37RefSeq] grch37RefSeq
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {string} [grch38RefSeq] grch38RefSeq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilUpdateTranscriptGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch37RefSeq?: string,
      grch38Isoform?: string,
      grch38RefSeq?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilUpdateTranscriptGetUsingGET(
        hugoSymbol,
        entrezGeneId,
        grch37Isoform,
        grch37RefSeq,
        grch38Isoform,
        grch38RefSeq,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilUpdateTranscriptGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary utilValidateTranscriptUpdateGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilValidateTranscriptUpdateGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch38Isoform?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilValidateTranscriptUpdateGetUsingGET(
        hugoSymbol,
        entrezGeneId,
        grch37Isoform,
        grch38Isoform,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilValidateTranscriptUpdateGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all the info for the query
     * @summary utilVariantAnnotationGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {string} [alteration] Alteration
     * @param {string} [hgvsg] HGVS genomic format. Example: 7:g.140453136A&gt;T
     * @param {string} [genomicChange] Genomic change format. Example: 7,140453136,140453136,A,T
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilVariantAnnotationGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      referenceGenome?: string,
      alteration?: string,
      hgvsg?: string,
      genomicChange?: string,
      tumorType?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantAnnotation>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilVariantAnnotationGetUsingGET(
        hugoSymbol,
        entrezGeneId,
        referenceGenome,
        alteration,
        hgvsg,
        genomicChange,
        tumorType,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilVariantAnnotationGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the list of Ensembl genes.
     * @summary utilsEnsemblGenesGet
     * @param {number} entrezGeneId Gene entrez id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsEnsemblGenesGetUsingGET(
      entrezGeneId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnsemblGene>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsEnsemblGenesGetUsingGET(entrezGeneId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsEnsemblGenesGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the list of evidences by levels.
     * @summary utilsEvidencesByLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsEvidencesByLevelsGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsEvidencesByLevelsGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsEvidencesByLevelsGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Determine whether variant is hotspot mutation.
     * @summary utilsHotspotMutationGet
     * @param {string} [hugoSymbol] Gene hugo symbol
     * @param {string} [variant] Variant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsHotspotMutationGetUsingGET(
      hugoSymbol?: string,
      variant?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsHotspotMutationGetUsingGET(hugoSymbol, variant, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsHotspotMutationGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get gene related numbers
     * @summary utilsNumbersGeneGet
     * @param {string} hugoSymbol The gene symbol used in Human Genome Organisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsNumbersGeneGetUsingGET(
      hugoSymbol: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneNumber>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsNumbersGeneGetUsingGET(hugoSymbol, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsNumbersGeneGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersGenesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsNumbersGenesGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneNumber>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsNumbersGenesGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsNumbersGenesGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsNumbersLevelsGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LevelNumber>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsNumbersLevelsGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsNumbersLevelsGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get numbers served for the main page dashboard.
     * @summary utilsNumbersMainGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsNumbersMainGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainNumber>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsNumbersMainGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsNumbersMainGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get All Suggested Variants.
     * @summary utilsSuggestedVariantsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsSuggestedVariantsGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotatedVariant>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsSuggestedVariantsGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsSuggestedVariantsGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the full list of TumorTypes.
     * @summary utilsTumorTypesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilsTumorTypesGetUsingGET(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TumorType>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilsTumorTypesGetUsingGET(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.utilsTumorTypesGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check if clinical trials are valid or not by nctId.
     * @summary validateTrials
     * @param {Array<string>} [nctIds] NCTID list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateTrialsUsingGET(
      nctIds?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateTrialsUsingGET(nctIds, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['UtilsApi.validateTrialsUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check if the genomic example will be mapped to OncoKB variant.
     * @summary validateVariantExampleGet
     * @param {string} [examples] The genomic examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateVariantExampleGetUsingGET(
      examples?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateVariantExampleGetUsingGET(examples, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.validateVariantExampleGetUsingGET']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check which OncoKB variants can be mapped on genomic examples.
     * @summary validateVariantExamplePost
     * @param {MatchVariantRequest} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validateVariantExamplePostUsingPOST(
      body: MatchVariantRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchVariantResult>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validateVariantExamplePostUsingPOST(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UtilsApi.validateVariantExamplePostUsingPOST']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UtilsApi - factory interface
 * @export
 */
export const UtilsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UtilsApiFp(configuration);
  return {
    /**
     * Annotate a string using CPL
     * @summary utilAnnotateCPL
     * @param {CplAnnotationRequest} cplRequest CPL Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilAnnotateCPLUsingPOST(cplRequest: CplAnnotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.utilAnnotateCPLUsingPOST(cplRequest, options).then(request => request(axios, basePath));
    },
    /**
     * Get information about what files are available by data version
     * @summary utilDataAvailabilityGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataAvailabilityGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<Array<DownloadAvailability>> {
      return localVarFp.utilDataAvailabilityGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Get readme info for specific data release version
     * @summary utilDataReadmeGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataReadmeGetUsingGET(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.utilDataReadmeGetUsingGET(version, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilDataSqlDumpGet
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataSqlDumpGetUsingGET(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp.utilDataSqlDumpGetUsingGET(version, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilDataTranscriptSqlDump
     * @param {string} [version] version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilDataTranscriptSqlDumpUsingGET(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
      return localVarFp.utilDataTranscriptSqlDumpUsingGET(version, options).then(request => request(axios, basePath));
    },
    /**
     * Filter genomic change based on oncokb coverage
     * @summary utilFilterGenomicChangeBasedOnCoveragePost
     * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(
      body: Array<AnnotateMutationByGenomicChangeQuery>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<string>> {
      return localVarFp.utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(body, options).then(request => request(axios, basePath));
    },
    /**
     * Filter HGVSg based on oncokb coverage
     * @summary utilFilterHgvsgBasedOnCoveragePost
     * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilFilterHgvsgBasedOnCoveragePostUsingPOST(
      body: Array<AnnotateMutationByHGVSgQuery>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<string>> {
      return localVarFp.utilFilterHgvsgBasedOnCoveragePostUsingPOST(body, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilMutationMapperDataGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilMutationMapperDataGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PortalAlteration>> {
      return localVarFp.utilMutationMapperDataGetUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilPortalAlterationSampleCountGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilPortalAlterationSampleCountGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CancerTypeCount>> {
      return localVarFp.utilPortalAlterationSampleCountGetUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
    /**
     * Get the list of relevant alterations
     * @summary utilRelevantAlterationsGet
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {number} [entrezGeneId] alteration
     * @param {string} [alteration] alteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantAlterationsGetUsingGET(
      referenceGenome?: string,
      entrezGeneId?: number,
      alteration?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Alteration>> {
      return localVarFp
        .utilRelevantAlterationsGetUsingGET(referenceGenome, entrezGeneId, alteration, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantCancerTypesPost
     * @param {Array<RelevantCancerTypeQuery>} body List of queries.
     * @param {UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum} [levelOfEvidence] Level of Evidence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantCancerTypesPostUsingPOST(
      body: Array<RelevantCancerTypeQuery>,
      levelOfEvidence?: UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<TumorType>> {
      return localVarFp.utilRelevantCancerTypesPostUsingPOST(body, levelOfEvidence, options).then(request => request(axios, basePath));
    },
    /**
     * Get the list of relevant tumor types.
     * @summary utilRelevantTumorTypesGet
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilRelevantTumorTypesGetUsingGET(tumorType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TumorType>> {
      return localVarFp.utilRelevantTumorTypesGetUsingGET(tumorType, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilUpdateTranscriptGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch37RefSeq] grch37RefSeq
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {string} [grch38RefSeq] grch38RefSeq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilUpdateTranscriptGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch37RefSeq?: string,
      grch38Isoform?: string,
      grch38RefSeq?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .utilUpdateTranscriptGetUsingGET(hugoSymbol, entrezGeneId, grch37Isoform, grch37RefSeq, grch38Isoform, grch38RefSeq, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary utilValidateTranscriptUpdateGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [grch37Isoform] grch37Isoform
     * @param {string} [grch38Isoform] grch38Isoform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilValidateTranscriptUpdateGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      grch37Isoform?: string,
      grch38Isoform?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .utilValidateTranscriptUpdateGetUsingGET(hugoSymbol, entrezGeneId, grch37Isoform, grch38Isoform, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get all the info for the query
     * @summary utilVariantAnnotationGet
     * @param {string} [hugoSymbol] hugoSymbol
     * @param {number} [entrezGeneId] entrezGeneId
     * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
     * @param {string} [alteration] Alteration
     * @param {string} [hgvsg] HGVS genomic format. Example: 7:g.140453136A&gt;T
     * @param {string} [genomicChange] Genomic change format. Example: 7,140453136,140453136,A,T
     * @param {string} [tumorType] OncoTree tumor type name/main type/code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilVariantAnnotationGetUsingGET(
      hugoSymbol?: string,
      entrezGeneId?: number,
      referenceGenome?: string,
      alteration?: string,
      hgvsg?: string,
      genomicChange?: string,
      tumorType?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VariantAnnotation> {
      return localVarFp
        .utilVariantAnnotationGetUsingGET(hugoSymbol, entrezGeneId, referenceGenome, alteration, hgvsg, genomicChange, tumorType, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Get the list of Ensembl genes.
     * @summary utilsEnsemblGenesGet
     * @param {number} entrezGeneId Gene entrez id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsEnsemblGenesGetUsingGET(entrezGeneId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<EnsemblGene>> {
      return localVarFp.utilsEnsemblGenesGetUsingGET(entrezGeneId, options).then(request => request(axios, basePath));
    },
    /**
     * Get the list of evidences by levels.
     * @summary utilsEvidencesByLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsEvidencesByLevelsGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp.utilsEvidencesByLevelsGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Determine whether variant is hotspot mutation.
     * @summary utilsHotspotMutationGet
     * @param {string} [hugoSymbol] Gene hugo symbol
     * @param {string} [variant] Variant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsHotspotMutationGetUsingGET(hugoSymbol?: string, variant?: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp.utilsHotspotMutationGetUsingGET(hugoSymbol, variant, options).then(request => request(axios, basePath));
    },
    /**
     * Get gene related numbers
     * @summary utilsNumbersGeneGet
     * @param {string} hugoSymbol The gene symbol used in Human Genome Organisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersGeneGetUsingGET(hugoSymbol: string, options?: RawAxiosRequestConfig): AxiosPromise<GeneNumber> {
      return localVarFp.utilsNumbersGeneGetUsingGET(hugoSymbol, options).then(request => request(axios, basePath));
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersGenesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersGenesGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneNumber>> {
      return localVarFp.utilsNumbersGenesGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Get gene related numbers of all genes. This is for main page word cloud.
     * @summary utilsNumbersLevelsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersLevelsGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<Array<LevelNumber>> {
      return localVarFp.utilsNumbersLevelsGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Get numbers served for the main page dashboard.
     * @summary utilsNumbersMainGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsNumbersMainGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<MainNumber> {
      return localVarFp.utilsNumbersMainGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Get All Suggested Variants.
     * @summary utilsSuggestedVariantsGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsSuggestedVariantsGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnotatedVariant>> {
      return localVarFp.utilsSuggestedVariantsGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Get the full list of TumorTypes.
     * @summary utilsTumorTypesGet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilsTumorTypesGetUsingGET(options?: RawAxiosRequestConfig): AxiosPromise<Array<TumorType>> {
      return localVarFp.utilsTumorTypesGetUsingGET(options).then(request => request(axios, basePath));
    },
    /**
     * Check if clinical trials are valid or not by nctId.
     * @summary validateTrials
     * @param {Array<string>} [nctIds] NCTID list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateTrialsUsingGET(nctIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp.validateTrialsUsingGET(nctIds, options).then(request => request(axios, basePath));
    },
    /**
     * Check if the genomic example will be mapped to OncoKB variant.
     * @summary validateVariantExampleGet
     * @param {string} [examples] The genomic examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateVariantExampleGetUsingGET(examples?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp.validateVariantExampleGetUsingGET(examples, options).then(request => request(axios, basePath));
    },
    /**
     * Check which OncoKB variants can be mapped on genomic examples.
     * @summary validateVariantExamplePost
     * @param {MatchVariantRequest} body List of queries. Please see swagger.json for request body format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateVariantExamplePostUsingPOST(
      body: MatchVariantRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<MatchVariantResult>> {
      return localVarFp.validateVariantExamplePostUsingPOST(body, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UtilsApi - object-oriented interface
 * @export
 * @class UtilsApi
 * @extends {BaseAPI}
 */
export class UtilsApi extends BaseAPI {
  /**
   * Annotate a string using CPL
   * @summary utilAnnotateCPL
   * @param {CplAnnotationRequest} cplRequest CPL Request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilAnnotateCPLUsingPOST(cplRequest: CplAnnotationRequest, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilAnnotateCPLUsingPOST(cplRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get information about what files are available by data version
   * @summary utilDataAvailabilityGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilDataAvailabilityGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilDataAvailabilityGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get readme info for specific data release version
   * @summary utilDataReadmeGet
   * @param {string} [version] version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilDataReadmeGetUsingGET(version?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilDataReadmeGetUsingGET(version, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilDataSqlDumpGet
   * @param {string} [version] version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilDataSqlDumpGetUsingGET(version?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilDataSqlDumpGetUsingGET(version, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilDataTranscriptSqlDump
   * @param {string} [version] version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilDataTranscriptSqlDumpUsingGET(version?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilDataTranscriptSqlDumpUsingGET(version, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Filter genomic change based on oncokb coverage
   * @summary utilFilterGenomicChangeBasedOnCoveragePost
   * @param {Array<AnnotateMutationByGenomicChangeQuery>} body List of queries.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(
    body: Array<AnnotateMutationByGenomicChangeQuery>,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilFilterGenomicChangeBasedOnCoveragePostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Filter HGVSg based on oncokb coverage
   * @summary utilFilterHgvsgBasedOnCoveragePost
   * @param {Array<AnnotateMutationByHGVSgQuery>} body List of queries.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilFilterHgvsgBasedOnCoveragePostUsingPOST(body: Array<AnnotateMutationByHGVSgQuery>, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilFilterHgvsgBasedOnCoveragePostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilMutationMapperDataGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilMutationMapperDataGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilMutationMapperDataGetUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilPortalAlterationSampleCountGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilPortalAlterationSampleCountGetUsingGET(hugoSymbol?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilPortalAlterationSampleCountGetUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the list of relevant alterations
   * @summary utilRelevantAlterationsGet
   * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
   * @param {number} [entrezGeneId] alteration
   * @param {string} [alteration] alteration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilRelevantAlterationsGetUsingGET(
    referenceGenome?: string,
    entrezGeneId?: number,
    alteration?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilRelevantAlterationsGetUsingGET(referenceGenome, entrezGeneId, alteration, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the list of relevant tumor types.
   * @summary utilRelevantCancerTypesPost
   * @param {Array<RelevantCancerTypeQuery>} body List of queries.
   * @param {UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum} [levelOfEvidence] Level of Evidence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilRelevantCancerTypesPostUsingPOST(
    body: Array<RelevantCancerTypeQuery>,
    levelOfEvidence?: UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilRelevantCancerTypesPostUsingPOST(body, levelOfEvidence, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the list of relevant tumor types.
   * @summary utilRelevantTumorTypesGet
   * @param {string} [tumorType] OncoTree tumor type name/main type/code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilRelevantTumorTypesGetUsingGET(tumorType?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilRelevantTumorTypesGetUsingGET(tumorType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilUpdateTranscriptGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {number} [entrezGeneId] entrezGeneId
   * @param {string} [grch37Isoform] grch37Isoform
   * @param {string} [grch37RefSeq] grch37RefSeq
   * @param {string} [grch38Isoform] grch38Isoform
   * @param {string} [grch38RefSeq] grch38RefSeq
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilUpdateTranscriptGetUsingGET(
    hugoSymbol?: string,
    entrezGeneId?: number,
    grch37Isoform?: string,
    grch37RefSeq?: string,
    grch38Isoform?: string,
    grch38RefSeq?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilUpdateTranscriptGetUsingGET(hugoSymbol, entrezGeneId, grch37Isoform, grch37RefSeq, grch38Isoform, grch38RefSeq, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary utilValidateTranscriptUpdateGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {number} [entrezGeneId] entrezGeneId
   * @param {string} [grch37Isoform] grch37Isoform
   * @param {string} [grch38Isoform] grch38Isoform
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilValidateTranscriptUpdateGetUsingGET(
    hugoSymbol?: string,
    entrezGeneId?: number,
    grch37Isoform?: string,
    grch38Isoform?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilValidateTranscriptUpdateGetUsingGET(hugoSymbol, entrezGeneId, grch37Isoform, grch38Isoform, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get all the info for the query
   * @summary utilVariantAnnotationGet
   * @param {string} [hugoSymbol] hugoSymbol
   * @param {number} [entrezGeneId] entrezGeneId
   * @param {string} [referenceGenome] Reference genome, either GRCh37 or GRCh38. The default is GRCh37
   * @param {string} [alteration] Alteration
   * @param {string} [hgvsg] HGVS genomic format. Example: 7:g.140453136A&gt;T
   * @param {string} [genomicChange] Genomic change format. Example: 7,140453136,140453136,A,T
   * @param {string} [tumorType] OncoTree tumor type name/main type/code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilVariantAnnotationGetUsingGET(
    hugoSymbol?: string,
    entrezGeneId?: number,
    referenceGenome?: string,
    alteration?: string,
    hgvsg?: string,
    genomicChange?: string,
    tumorType?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UtilsApiFp(this.configuration)
      .utilVariantAnnotationGetUsingGET(hugoSymbol, entrezGeneId, referenceGenome, alteration, hgvsg, genomicChange, tumorType, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the list of Ensembl genes.
   * @summary utilsEnsemblGenesGet
   * @param {number} entrezGeneId Gene entrez id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsEnsemblGenesGetUsingGET(entrezGeneId: number, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsEnsemblGenesGetUsingGET(entrezGeneId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the list of evidences by levels.
   * @summary utilsEvidencesByLevelsGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsEvidencesByLevelsGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsEvidencesByLevelsGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Determine whether variant is hotspot mutation.
   * @summary utilsHotspotMutationGet
   * @param {string} [hugoSymbol] Gene hugo symbol
   * @param {string} [variant] Variant name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsHotspotMutationGetUsingGET(hugoSymbol?: string, variant?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsHotspotMutationGetUsingGET(hugoSymbol, variant, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get gene related numbers
   * @summary utilsNumbersGeneGet
   * @param {string} hugoSymbol The gene symbol used in Human Genome Organisation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsNumbersGeneGetUsingGET(hugoSymbol: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsNumbersGeneGetUsingGET(hugoSymbol, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get gene related numbers of all genes. This is for main page word cloud.
   * @summary utilsNumbersGenesGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsNumbersGenesGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsNumbersGenesGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get gene related numbers of all genes. This is for main page word cloud.
   * @summary utilsNumbersLevelsGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsNumbersLevelsGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsNumbersLevelsGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get numbers served for the main page dashboard.
   * @summary utilsNumbersMainGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsNumbersMainGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsNumbersMainGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get All Suggested Variants.
   * @summary utilsSuggestedVariantsGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsSuggestedVariantsGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsSuggestedVariantsGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Get the full list of TumorTypes.
   * @summary utilsTumorTypesGet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public utilsTumorTypesGetUsingGET(options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .utilsTumorTypesGetUsingGET(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Check if clinical trials are valid or not by nctId.
   * @summary validateTrials
   * @param {Array<string>} [nctIds] NCTID list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public validateTrialsUsingGET(nctIds?: Array<string>, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .validateTrialsUsingGET(nctIds, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Check if the genomic example will be mapped to OncoKB variant.
   * @summary validateVariantExampleGet
   * @param {string} [examples] The genomic examples.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public validateVariantExampleGetUsingGET(examples?: string, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .validateVariantExampleGetUsingGET(examples, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Check which OncoKB variants can be mapped on genomic examples.
   * @summary validateVariantExamplePost
   * @param {MatchVariantRequest} body List of queries. Please see swagger.json for request body format.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilsApi
   */
  public validateVariantExamplePostUsingPOST(body: MatchVariantRequest, options?: RawAxiosRequestConfig) {
    return UtilsApiFp(this.configuration)
      .validateVariantExamplePostUsingPOST(body, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum = {
  Level1: 'LEVEL_1',
  Level2: 'LEVEL_2',
  Level3A: 'LEVEL_3A',
  Level3B: 'LEVEL_3B',
  Level4: 'LEVEL_4',
  LevelR1: 'LEVEL_R1',
  LevelR2: 'LEVEL_R2',
  LevelPx1: 'LEVEL_Px1',
  LevelPx2: 'LEVEL_Px2',
  LevelPx3: 'LEVEL_Px3',
  LevelDx1: 'LEVEL_Dx1',
  LevelDx2: 'LEVEL_Dx2',
  LevelDx3: 'LEVEL_Dx3',
  LevelFda1: 'LEVEL_Fda1',
  LevelFda2: 'LEVEL_Fda2',
  LevelFda3: 'LEVEL_Fda3',
  No: 'NO',
} as const;
export type UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum =
  (typeof UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum)[keyof typeof UtilRelevantCancerTypesPostUsingPOSTLevelOfEvidenceEnum];
